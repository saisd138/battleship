<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battleship Royale</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom game-specific styles */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Constants for grid size - MOBILE FIRST */
        :root {
            --grid-size: 6;
            --cell-size: 20px; /* Mobile size */
            --label-size: 20px; /* Mobile size */
        }
        
        /* NEW: Tablet grid size */
        @media (min-width: 640px) { /* sm */
             :root {
                --cell-size: 28px;
                --label-size: 28px;
            }
        }
        
        /* Desktop grid sizes */
        @media (min-width: 1024px) { /* lg */
            :root {
                --cell-size: 35px; /* Desktop size */
                --label-size: 35px; /* Desktop size */
            }
        }

        /* Base cell style */
        .grid-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: #cce7ff; /* light-blue-100 */
            border: 1px solid #a3d5ff; /* light-blue-200 */
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; /* Mobile font size */
            font-weight: bold;
            transition: all 0.15s ease-in-out;
            position: relative;
        }
        @media (min-width: 1024px) { /* lg */
            .grid-cell {
                font-size: 1rem; /* Desktop font size */
            }
        }


        /* Row/Col labels */
        .grid-label {
            width: var(--label-size);
            height: var(--label-size);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.625rem; /* Mobile font size */
            font-weight: 600;
            color: #6b7280; /* gray-500 */
        }
        @media (min-width: 1024px) { /* lg */
            .grid-label {
                font-size: 0.75rem; /* Desktop font size */
            }
        }

        .grid-wrapper {
            display: grid;
            /* 1 label + 6 cells */
            grid-template-columns: var(--label-size) repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: var(--label-size) repeat(var(--grid-size), var(--cell-size));
            gap: 2px;
        }

        /* My grid: hover effect */
        .my-grid .grid-cell:not(.ship):not(.miss):not(.hit):not(.ship-selected-for-move):not(.move-option):not(.mine):hover {
            background-color: #a3d5ff; /* light-blue-200 */
        }
        
        /* My grid: placed ship */
        .my-grid .grid-cell.ship {
            background-color: #4b5563; /* gray-600 */
            border-color: #374151; /* gray-700 */
        }
        
        /* My grid: placed mine */
        .my-grid .grid-cell.mine {
            background-color: #cce7ff; /* light-blue-100 */
            border-color: #a3d5ff;
            color: #f97316; /* orange-500 */
        }

        /* Opponent grid: fog of war (looks default) */
        .opponent-grid .grid-cell.ship,
        .opponent-grid .grid-cell.mine {
            background-color: #cce7ff; /* light-blue-100 */
            cursor: not-allowed;
        }

        /* Opponent grid: active turn hover effect */
        .opponent-grid.turn-active .grid-cell:not(.miss):not(.hit):not(.mine-hit):not(.last-move):hover {
            background-color: #fef08a; /* yellow-200 */
            border-color: #fde047; /* yellow-300 */
        }
        
        /* All grids: miss */
        .grid-cell.miss {
            cursor: not-allowed;
            /* Color is set by JS */
        }
        
        /* All grids: hit */
        .grid-cell.hit {
            /* Background-color is set by JS */
            border-color: #4b5563; /* gray-600 */
            cursor: not-allowed;
            animation: hit-animation 0.5s ease;
            color: #1f2937; /* gray-800 */
        }
        
        /* All grids: mine hit */
        .grid-cell.mine-hit {
            /* Background-color is set by JS */
            border-color: #ef4444; /* red-500 */
            cursor: not-allowed;
            animation: hit-animation 0.5s ease;
            color: #7f1d1d; /* red-900 */
        }
        
        @keyframes hit-animation {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Style for ship selected to be moved */
        .grid-cell.ship-selected-for-move {
            background-color: #fef08a; /* yellow-200 */
            border-color: #fde047; /* yellow-300 */
            box-shadow: 0 0 10px #fde047;
        }

        /* Style for valid move options */
        .grid-cell.move-option {
            background-color: #cce7ff;
            border: 2px dashed #facc15; /* yellow-400 */
            cursor: pointer;
        }
        .grid-cell.move-option:hover {
            background-color: #fef9c3; /* yellow-100 */
        }
        
        /* Last move highlight */
        .grid-cell.last-move {
            border: 3px solid #facc15; /* yellow-400 */
            box-shadow: 0 0 10px #facc15;
        }

        /* Player card when out */
        .player-out-card {
            background-color: #f3f4f6; /* gray-100 */
            border: 2px dashed #fca5a5; /* red-300 */
            color: #9ca3af; /* gray-400 */
            
            /* Sizing adjusted for variable cell size */
            width: calc( (var(--cell-size) * 7) + (2px * 6) + (8px * 2) - 17px );
            height: calc( (var(--cell-size) * 7) + (2px * 6) + (8px * 2) + 18px + 20px );

            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }
        
        /* Sizing for Desktop */
        @media (min-width: 1024px) { /* lg */
            .player-out-card {
                padding: 16px;
            }
        }
        
        /* NEW: Disconnected player overlay/style */
        .player-disconnected .grid-wrapper,
        .player-disconnected h3,
        .player-disconnected p {
            opacity: 0.5;
            pointer-events: none; /* Prevent interaction with disconnected grids */
        }
        .player-disconnected-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            background-color: rgba(239, 68, 68, 0.8); /* red-500 with opacity */
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: bold;
            z-index: 5;
            pointer-events: none;
        }


        /* Modal backdrop */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.25);
        }

        /* Color picker */
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.15s ease;
        }
        .color-swatch.selected {
            border-color: #2563eb; /* blue-600 */
            box-shadow: 0 0 0 3px #fff;
        }
        .color-swatch:hover:not(.disabled) {
            opacity: 0.8;
        }
        .color-swatch.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            position: relative;
        }
        /* "X" mark for disabled colors */
        .color-swatch.disabled::before,
        .color-swatch.disabled::after {
            position: absolute;
            content: '';
            width: 70%;
            height: 2px;
            background-color: #4b5563;
            top: 50%;
            left: 15%;
            transform: rotate(45deg);
        }
        .color-swatch.disabled::after {
            transform: rotate(-45deg);
        }

        /* Game event log messages */
        .log-game-event {
            color: #DC2626; /* red-600 */
            font-style: italic;
            font-size: 0.875rem; /* text-sm */
        }
        
        /* Chat messages */
        .log-chat-message {
            font-size: 0.875rem; /* text-sm */
            word-break: break-word; /* Ensure long messages wrap */
        }
        
        /* Kick Button Style */
        .kick-button {
            font-size: 0.75rem; /* text-xs */
            font-weight: 500;
            color: #DC2626; /* red-600 */
            margin-left: 8px;
            cursor: pointer;
        }
        .kick-button:hover {
            color: #991B1B; /* red-800 */
            text-decoration: underline;
        }
        
        /* In-game kick button (on opponent grid) */
        .kick-button-ingame {
            position: absolute;
            top: 2px;
            right: 2px;
            background-color: rgba(255, 255, 255, 0.8);
            color: #DC2626;
            border: 1px solid #DC2626;
            border-radius: 4px;
            padding: 0 4px;
            font-size: 0.625rem; /* 10px */
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            z-index: 10;
        }
        .kick-button-ingame:hover {
            background-color: #DC2626;
            color: white;
        }


    </style>
</head>
<body class="bg-gray-50 text-gray-900 min-h-screen p-4 sm:p-6">

    <!-- Main Game Container -->
    <div id="app-container" class="max-w-screen-2xl mx-auto">

        <!-- Loading Screen -->
        <div id="loading-screen" class="text-center p-12">
            <h1 class="text-3xl font-bold text-cyan-600">Battleship Royale</h1>
            <p class="text-xl mt-4">Initializing connection...</p>
        </div>

        <!-- Login Screen -->
        <div id="login-screen" class="hidden max-w-lg mx-auto bg-white p-8 rounded-lg shadow-xl">
            <h1 class="text-3xl font-bold text-center text-cyan-600 mb-6">Battleship Royale</h1>
            
            <div class="space-y-4">
                <!-- Shared Name Input -->
                <div>
                    <label for="name-input" class="block text-sm font-medium text-gray-700 mb-1">Your Name</label>
                    <input type="text" id="name-input" class="w-full bg-white border border-gray-300 rounded-md p-3 text-gray-900 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="E.g., Captain-A">
                </div>

                <!-- Create Room -->
                <div class="border-b border-gray-200 pb-6">
                    <button id="create-room-button" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-md shadow-lg transition duration-200 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-50">
                        Create New Game
                    </button>
                </div>

                <!-- Join Room -->
                <div class="pt-4 space-y-4">
                    <p class="text-center text-gray-500 text-sm">...or join an existing game:</p>
                    <div>
                        <label for="room-input" class="block text-sm font-medium text-gray-700 mb-1">5-Character Room Code</label>
                        <input type="text" id="room-input" class="w-full bg-white border border-gray-300 rounded-md p-3 text-gray-900 font-mono uppercase focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="XYZ12" maxlength="5">
                    </div>
                    <button id="join-button" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-md shadow-lg transition duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                        Join Game
                    </button>
                </div>
                
                <p id="login-error" class="text-red-500 text-center text-sm h-4"></p>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden">
            <!-- Header -->
            <div class="bg-white p-4 rounded-lg shadow-lg mb-6 flex flex-col sm:flex-row justify-between items-center space-y-2 sm:space-y-0">
                <div class="flex items-center gap-2">
                    <span class="text-sm text-gray-500">Room:</span>
                    <span id="room-display" class="text-xl font-bold font-mono text-yellow-500"></span>
                </div>
                <!-- Exit Button -->
                <div class="flex gap-2">
                    <button id="exit-room-button" class="hidden bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-md shadow-lg transition duration-200 text-sm">
                        Exit Room
                    </button>
                </div>
                <h2 id="game-status" class="text-2xl font-bold text-center text-cyan-600">Waiting for players...</h2>
                <div>
                    <span class="text-sm text-gray-500">Player:</span>
                    <span id="my-name-display" class="text-xl font-bold text-gray-900"></span>
                </div>
            </div>

            <!-- Main Game Layout -->
            <div class="flex flex-col lg:flex-row gap-6">

                <!-- Left Column (My Grid + Setup) -->
                <div class="flex flex-col items-center lg:items-start flex-shrink-0 w-full lg:w-auto">
                    <!-- Setup Controls -->
                    <div id="setup-controls" class="hidden bg-white p-4 rounded-lg shadow-lg mb-6 text-center">
                        <h3 id="setup-instructions" class="text-xl font-semibold text-yellow-600">Place your 5 ships.</h3>
                        <p class="text-lg mt-2">
                            Ships: <span id="ships-placed-count" class="font-bold text-2xl">0</span> / 5
                            |
                            Mines: <span id="mines-placed-count" class="font-bold text-2xl">0</span> / 3
                        </p>
                        <button id="ready-button" disabled class="mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-md shadow-lg transition duration-200 disabled:bg-gray-400 disabled:cursor-not-allowed">
                            Ready
                        </button>
                    </div>

                    <!-- My Grid Container -->
                    <div id="my-grid-container" class="bg-white p-2 sm:p-4 rounded-lg shadow-lg relative">
                        <!-- My grid will be inserted here -->
                    </div>
                </div>

                <!-- Right Column (Opponent Grids) -->
                <div class="flex-1 min-w-0">
                    <div class="bg-white p-2 sm:p-4 rounded-lg shadow-lg h-full">
                        <h3 class="text-xl sm:text-2xl font-bold text-gray-800 mb-4 text-center sm:text-left">Opponents</h3>
                        <!-- Opponent Grids Area -->
                        <!-- Responsive grid columns -->
                        <div id="opponent-grids-container" class="grid grid-cols-2 sm:grid-cols-3 lg:flex lg:flex-wrap justify-center lg:justify-start gap-2 sm:gap-4 overflow-y-auto p-1 sm:p-2 bg-gray-50 rounded-md" style="max-height: calc(100vh - 300px);">
                            <!-- Opponent grids will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Game Log (REVERSED) -->
            <div class="mt-6">
                <h3 class="text-xl font-semibold mb-2 text-gray-700">Game Log / Chat</h3>
                <!-- Chat Input (MOVED) -->
                <div id="chat-controls" class="mt-2 hidden">
                    <div class="flex gap-2">
                        <input type="text" id="chat-input" class="flex-grow bg-white border border-gray-300 rounded-md p-2 text-sm text-gray-900 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="Type a message...">
                        <button id="chat-send-button" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded-md shadow-lg transition duration-200">
                            Send
                        </button>
                    </div>
                </div>
                <!-- Log Container (MOVED) -->
                <div id="game-log-container" class="h-48 bg-gray-100 rounded-lg p-4 overflow-y-auto shadow-inner space-y-2 mt-2">
                    <!-- Log messages will be inserted here -->
                </div>
            </div>
            
            <!-- Start Game Button (for waiting room) -->
            <div id="waiting-room-controls" class="bg-white p-6 rounded-lg shadow-lg text-center mt-6">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Waiting Room</h3>
                
                <!-- Player List -->
                <div id="player-list-container" class="flex flex-wrap justify-center gap-4 mb-6">
                    <!-- Player list will be inserted here -->
                </div>
                
                <!-- Color Picker ADDED here -->
                <div class="border-t border-gray-200 pt-6 mt-6">
                    <label class="block text-lg font-medium text-gray-700 mb-4">Choose Your Color</label>
                    <div id="room-color-picker" class="flex flex-wrap justify-center gap-3 max-w-md mx-auto">
                        <!-- Swatches will be injected here -->
                    </div>
                </div>

                <!-- Start Button -->
                <div class="border-t border-gray-200 pt-6 mt-6">
                    <button id="start-game-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-md shadow-lg text-xl transition duration-200">
                        Start Game
                    </button>
                    <p id="start-game-error" class="text-red-500 text-sm mt-2 h-4"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Generic Message Modal -->
    <div id="message-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center">
            <p id="message-text" class="text-xl text-gray-800 mb-6">This is a message.</p>
            <button id="message-ok-button" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-6 rounded-md">
                OK
            </button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop">
        <div class="bg-white rounded-lg shadow-xl p-12 text-center">
            <h2 class="text-5xl font-bold text-yellow-500 mb-6">Game Over!</h2>
            <p class="text-3xl text-gray-800 mb-8">
                Winner: <span id="winner-name" class="font-bold text-cyan-600"></span>
            </p>
            <button id="play-again-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-md shadow-lg text-xl transition duration-200">
                Play Again
            </button>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc, 
            updateDoc, 
            onSnapshot, 
            arrayUnion, 
            serverTimestamp,
            setLogLevel,
            Timestamp // NEW: Import Timestamp
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Game Constants ---
        const GRID_SIZE = 6;
        const SHIP_COUNT = 5;
        const MINE_COUNT = 3;
        const MAX_PLAYERS = 20;
        const PRESENCE_UPDATE_INTERVAL = 20000; // Update lastSeen every 20 seconds
        const DISCONNECT_TIMEOUT = 45000;      // Consider disconnected after 45 seconds
        const KICK_TIMEOUT = 30000;            // Allow kicking after 30 seconds disconnected

        // --- Global Variables ---
        let app, db, auth;
        let userId, myPlayerName, currentRoomCode;
        let localGameData = null;
        let oldLocalGameData = null; // Store previous state
        let unsubscribeRoom = null;
        let isSpectator = false;
        let presenceIntervalId = null; // NEW: Interval timer for presence
        let disconnectedPlayers = {}; // NEW: Track players marked as disconnected { userId: timestamp }
        
        // State for click-to-move
        let shipToMoveIndex = null;  // Index of the ship being moved
        let validMoveIndices = [];   // Array of valid destination indices
        let hasMovedShipThisTurn = false; // Local flag for ship movement

        // Darker Pastel colors
        const PLAYER_COLORS = [
            '#60A5FA', // blue-400
            '#FB923C', // orange-400
            '#4ADE80', // green-400
            '#A78BFA', // violet-400
            '#FACC15', // yellow-400
            '#2DD4BF', // teal-400
            '#C084FC', // purple-400
            '#84CC16', // lime-500
            '#F97316', // orange-500
            '#5EEAD4', // cyan-300
            '#EC4899', // pink-500
            '#67CDBB', // Custom
            '#7BC6CC', // Custom
            '#D19ED4', // Custom
            '#6EE7B7', // emerald-300
            '#FADB5F', // Custom yellow
            '#99DDE0'  // Custom
        ];
        const DEFAULT_COLOR = '#6b7280'; // Gray

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyBaNyxRMOTb7a-NYu7Y1J1Q4pSweC-qZUQ",
            authDomain: "battleship-royal.firebaseapp.com",
            projectId: "battleship-royal",
            storageBucket: "battleship-royal.firebasestorage.app",
            messagingSenderId: "246405120799",
            appId: "1:246405120799:web:1ac4da9d7c951dfa96262a"
        };
        
        // This is a unique ID for your app's data in the database.
        const appId = 'battleship-royale-local'; 

        // --- DOM Elements ---
        const loadingScreen = document.getElementById('loading-screen');
        const loginScreen = document.getElementById('login-screen');
        const gameScreen = document.getElementById('game-screen');
        
        const nameInput = document.getElementById('name-input');
        const roomInput = document.getElementById('room-input');
        const joinButton = document.getElementById('join-button');
        const createRoomButton = document.getElementById('create-room-button');
        const loginError = document.getElementById('login-error');

        const roomDisplay = document.getElementById('room-display');
        const gameStatus = document.getElementById('game-status');
        const myNameDisplay = document.getElementById('my-name-display');
        const exitRoomButton = document.getElementById('exit-room-button');
        
        const setupControls = document.getElementById('setup-controls');
        const setupInstructions = document.getElementById('setup-instructions');
        const shipsPlacedCount = document.getElementById('ships-placed-count');
        const minesPlacedCount = document.getElementById('mines-placed-count');
        const readyButton = document.getElementById('ready-button');
        
        const myGridContainer = document.getElementById('my-grid-container');
        const opponentGridsContainer = document.getElementById('opponent-grids-container');
        const gameLogContainer = document.getElementById('game-log-container');

        const chatControls = document.getElementById('chat-controls');
        const chatInput = document.getElementById('chat-input');
        const chatSendButton = document.getElementById('chat-send-button');
        
        const waitingRoomControls = document.getElementById('waiting-room-controls');
        const playerListContainer = document.getElementById('player-list-container');
        const roomColorPicker = document.getElementById('room-color-picker'); 
        const startGameButton = document.getElementById('start-game-button');
        const startGameError = document.getElementById('start-game-error');
        
        const messageModal = document.getElementById('message-modal');
        const messageText = document.getElementById('message-text');
        const messageOkButton = document.getElementById('message-ok-button');
        
        const gameOverModal = document.getElementById('game-over-modal');
        const winnerName = document.getElementById('winner-name');
        const playAgainButton = document.getElementById('play-again-button');

        // --- Utility Functions ---

        /**
         * Shows a custom modal message.
         * @param {string} message - The message to display.
         */
        function showMessage(message) {
            messageText.textContent = message;
            messageModal.classList.remove('hidden');
        }

        /**
         * Generates a random, uppercase, alphanumeric room code.
         * @param {number} length - The desired length of the code.
         * @returns {string} - The generated room code.
         */
        function generateRoomCode(length) {
            const chars = 'ABCDEFGHIJKLMNPQRSTUVWXYZ123456789'; // Omitted O and 0 for clarity
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        /**
         * Gets the Firestore path for the current room.
         * @returns {string} - The document path.
         */
        function getRoomPath() {
            if (!currentRoomCode) return null; // Safety check
            return `artifacts/${appId}/public/data/battleship_rooms/${currentRoomCode}`;
        }

        /**
         * Converts row and column to a 0-35 index.
         * @param {number} row - The row (0-5).
         * @param {number} col - The column (0-5).
         * @returns {number} - The grid index (0-35).
         */
        function toIndex(row, col) {
            return row * GRID_SIZE + col;
        }

        /**
         * Converts a grid index to row/col object.
         * @param {number} index - The grid index (0-35).
         * @returns {object} - { row, col }
         */
        function toRowCol(index) {
            return {
                row: Math.floor(index / GRID_SIZE),
                col: index % GRID_SIZE
            };
        }

        /**
         * Converts a grid index to "A1" style coordinates.
         * @param {number} index - The grid index (0-35).
         * @returns {string} - The coordinate string (e.g., "A1", "F6").
         */
        function toGridCoord(index) {
            const { row, col } = toRowCol(index);
            const rowLabel = ['A', 'B', 'C', 'D', 'E', 'F'][row];
            const colLabel = col + 1;
            return `${rowLabel}${colLabel}`;
        }

        /**
         * Creates a new player object.
         * @returns {object} - The player object.
         */
        function createNewPlayer() {
            return {
                userId: userId,
                name: myPlayerName,
                color: null, 
                grid: Array(GRID_SIZE * GRID_SIZE).fill(0),
                shipsPlaced: 0,
                minesPlaced: 0,
                shipsLeft: SHIP_COUNT, 
                isOut: false,
                ready: false,
                isSkippingTurn: false,
                lastSeen: serverTimestamp() // NEW: Add lastSeen on creation
            };
        }

        /**
         * Creates the HTML for a single player's grid.
         * @param {object} player - The player data object.
         * @param {boolean} isMe - Is this grid for the current user?
         * @param {boolean} isTurnActive - Is it my turn and this is an opponent?
         * @returns {string} - The HTML string for the grid.
         */
        function createGridHTML(player, isMe, isTurnActive = false) {
            let gridClasses = isMe ? 'my-grid' : 'opponent-grid' + (isTurnActive ? ' turn-active' : '');
            let cellsHTML = '';
            const playerColor = player.color || DEFAULT_COLOR;
            const isCreator = localGameData.creatorId === userId;
            const isDisconnected = disconnectedPlayers[player.userId]; // Check disconnect status
            const canKickDisconnected = isDisconnected && (Date.now() - disconnectedPlayers[player.userId] > KICK_TIMEOUT);

            // Add disconnected style if needed
            if (isDisconnected && !isMe) {
                 gridClasses += ' player-disconnected';
            }
            
            // Allow kicking if host OR if player is disconnected for long enough
            const kickButtonHTML = ((isCreator || canKickDisconnected) && !isMe)
                ? `<button data-kick-id="${player.userId}" class="kick-button-ingame">Kick</button>`
                : '';
                
            const disconnectedLabelHTML = (isDisconnected && !isMe)
                ? `<div class="player-disconnected-label">Disconnected</div>`
                : '';
            
            // Add column headers
            cellsHTML += '<div class="grid-label"></div>'; // Empty corner
            for (let c = 1; c <= GRID_SIZE; c++) {
                cellsHTML += `<div class="grid-label">${c}</div>`;
            }

            // Add rows with headers
            const rowLabels = ['A', 'B', 'C', 'D', 'E', 'F']; 
            for (let r = 0; r < GRID_SIZE; r++) {
                cellsHTML += `<div class="grid-label">${rowLabels[r]}</div>`; // Row header
                for (let c = 0; c < GRID_SIZE; c++) {
                    const i = toIndex(r, c);
                    const cellState = player.grid[i];
                    let cellClass = 'grid-cell';
                    let content = '';
                    let style = '';

                    if (isMe) {
                        // My Grid: Show everything
                        if (cellState === 1) cellClass += ' ship';
                        if (cellState === 2) { 
                            cellClass += ' mine';
                            content = '💣';
                        }
                        
                        if (typeof cellState === 'object') {
                            if (cellState.type === 'miss') {
                                cellClass += ' miss';
                                content = 'X';
                                style = `color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'hit') {
                                cellClass += ' hit';
                                content = '🚢';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'mine-hit') {
                                cellClass += ' mine-hit';
                                content = '💥';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            }
                        }
                        // Show highlight if selected for moving
                        if (i === shipToMoveIndex) {
                            cellClass += ' ship-selected-for-move';
                        }
                        // Show highlight if it's a valid move option
                        if (validMoveIndices.includes(i)) {
                            cellClass += ' move-option';
                        }
                    } else {
                        // Opponent Grid: Show only hits and misses
                        if (typeof cellState === 'object') {
                             if (cellState.type === 'miss') {
                                cellClass += ' miss';
                                content = 'X';
                                style = `color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'hit') {
                                cellClass += ' hit';
                                content = '🚢';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'mine-hit') {
                                cellClass += ' mine-hit';
                                content = '💥';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            }
                        }
                    }
                    
                    if (localGameData.lastMove && localGameData.lastMove.playerId === player.userId && localGameData.lastMove.cellIndex === i) {
                        cellClass += ' last-move';
                    }
                    
                    cellsHTML += `<div class="${cellClass}" data-player-id="${player.userId}" data-row="${r}" data-col="${c}" style="${style}">${content}</div>`;
                }
            }

            return `
                <div class="p-2 sm:p-4 rounded-lg shadow-md ${gridClasses} ${isMe ? 'bg-blue-50' : 'bg-gray-50'} relative">
                    ${disconnectedLabelHTML}
                    ${kickButtonHTML}
                    <h3 class="font-bold text-base sm:text-lg text-center mb-2" style="color: ${playerColor};">${player.name}</h3>
                    <p class="text-center text-xs sm:text-sm text-gray-600 mb-2 sm:mb-3">Ships Left: ${player.shipsLeft}</p>
                    ${player.isSkippingTurn ? '<p class="text-center text-xs sm:text-sm text-red-500 font-bold mb-2">SKIPPING TURN</p>' : ''}
                    <div class="grid-wrapper">
                        ${cellsHTML}
                    </div>
                </div>
            `;
        }

        /**
         * Creates an "Eliminated Player" card.
         * @param {object} player - The eliminated player object.
         * @returns {string} - The HTML string for the card.
         */
        function createPlayerOutHTML(player) {
            return `
                <div class="p-2 sm:p-4 rounded-lg shadow-md player-out-card">
                    <h3 class="font-bold text-base sm:text-lg text-center mb-3 text-gray-500">${player.name}</h3>
                    <p class="text-xl sm:text-2xl text-red-500 font-bold">ELIMINATED</p>
                </div>
            `;
        }

        /**
         * Renders the color picker in the waiting room.
         * @param {object} roomData - The current room data.
         */
        function renderColorPicker(roomData) {
            roomColorPicker.innerHTML = ''; // Clear existing swatches
            const usedColors = roomData.players.map(p => p.color).filter(Boolean);
            const myColor = roomData.players.find(p => p.userId === userId)?.color;

            PLAYER_COLORS.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.dataset.color = color;

                if (usedColors.includes(color) && color !== myColor) {
                    swatch.classList.add('disabled');
                }
                
                if (color === myColor) {
                    swatch.classList.add('selected');
                }
                
                roomColorPicker.appendChild(swatch);
            });
        }
        
        // --- Main UI Render Function ---

        /**
         * Renders the entire game UI based on the current game state.
         * @param {object} roomData - The data from Firestore.
         */
        function renderGameUI(roomData) {
            if (!roomData) return;
            
            const myPlayer = roomData.players.find(p => p.userId === userId);

            // Kicked / Rejoin Logic
            if (!myPlayer && !isSpectator) {
                // Kicked or data mismatch, return to login
                showMessage("You have been removed from the game.");
                showLoginScreen();
                return;
            }
            
            // Update header
            roomDisplay.textContent = currentRoomCode;
            myNameDisplay.textContent = myPlayerName + (isSpectator ? " (Spectator)" : "");
            
            // Clear main containers
            myGridContainer.innerHTML = ''; // Will be re-filled
            opponentGridsContainer.innerHTML = '';
            gameLogContainer.innerHTML = '';
            playerListContainer.innerHTML = '';
            
            // Hide all conditional controls
            setupControls.classList.add('hidden');
            waitingRoomControls.classList.add('hidden');
            gameOverModal.classList.add('hidden');
            chatControls.classList.add('hidden'); // Hide chat by default
            
            // Render Game Log
            roomData.gameLog.slice().reverse().forEach(logEntry => {
                const p = document.createElement('p');
                if (logEntry.type === 'chat') {
                    p.className = 'log-chat-message';
                    // Sanitize message - very basic sanitation
                    const safeMessage = logEntry.message
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&#039;");
                    p.innerHTML = `<span class="font-bold" style="color: ${logEntry.color || DEFAULT_COLOR};">${logEntry.name}:</span> ${safeMessage}`;
                } else {
                    // Default to game event
                    p.className = 'log-game-event';
                    p.textContent = logEntry.message;
                }
                gameLogContainer.appendChild(p);
            });
            
            // --- NEW: Spectator UI ---
            if (isSpectator) {
                gameStatus.textContent = "Spectating Game in Progress";
                if (roomData.gameState === 'over') {
                    gameStatus.textContent = "Game Over!";
                }
                
                myGridContainer.innerHTML = `
                    <div class="p-4 h-full flex flex-col items-center justify-center text-center">
                        <h3 class="text-xl font-bold text-gray-700">Spectator Mode</h3>
                        <p class="text-gray-500 mt-2">You are watching this game. You do not have a grid.</p>
                    </div>
                `;

                // Render all player grids as opponents
                roomData.players.forEach(player => {
                    if (player.isOut) {
                        opponentGridsContainer.innerHTML += createPlayerOutHTML(player);
                    } else {
                        opponentGridsContainer.innerHTML += createGridHTML(player, false, false); // Never "my turn"
                    }
                });
                
                if (roomData.gameState === "over") {
                    const winner = roomData.players.find(p => p.userId === roomData.winner);
                    winnerName.textContent = winner ? winner.name : 'Unknown';
                    gameOverModal.classList.remove('hidden');
                }
                chatControls.classList.add('hidden'); // Spectators cannot chat
                return; // End render function for spectators
            }

            // --- Player UI (existing logic) ---
            switch (roomData.gameState) {
                case "waiting":
                    gameStatus.textContent = "Waiting for Players... (Share Code!)";
                    waitingRoomControls.classList.remove('hidden');
                    const isCreator = localGameData.creatorId === userId;
                    
                    roomData.players.forEach(player => {
                        const isDisconnected = disconnectedPlayers[player.userId]; // Check disconnect status
                        const canKickDisconnected = isDisconnected && (Date.now() - disconnectedPlayers[player.userId] > KICK_TIMEOUT);

                        const kickButtonHTML = ((isCreator || canKickDisconnected) && player.userId !== userId)
                            ? `<button data-kick-id="${player.userId}" class="kick-button">Kick</button>`
                            : '';
                            
                        const playerCard = `
                            <div class="p-4 bg-gray-100 rounded-lg shadow-md w-full max-w-xs text-center flex justify-between items-center ${isDisconnected ? 'opacity-50' : ''}">
                                <h3 class="font-bold text-xl" style="color: ${player.color || DEFAULT_COLOR};">${player.name} ${isDisconnected ? '(Disconnected)' : ''}</h3>
                                <div>
                                    ${player.color ? '' : '<span class="text-xs text-red-500">Choosing color...</span>'}
                                    ${kickButtonHTML}
                                </div>
                            </div>
                        `;
                        playerListContainer.innerHTML += playerCard;
                    });
                    
                    chatControls.classList.remove('hidden'); // Show chat for players
                    renderColorPicker(roomData);
                    break;

                case "setup":
                    setupControls.classList.remove('hidden');
                    shipsPlacedCount.textContent = myPlayer.shipsPlaced;
                    minesPlacedCount.textContent = myPlayer.minesPlaced;
                    
                    if (myPlayer.shipsPlaced < SHIP_COUNT) {
                        gameStatus.textContent = "Place Your Ships!";
                        setupInstructions.textContent = `Place your ${SHIP_COUNT} ships. (Click on grid)`;
                    } else if (myPlayer.minesPlaced < MINE_COUNT) {
                        gameStatus.textContent = "Place Your Mines!";
                        setupInstructions.textContent = `Place your ${MINE_COUNT} mines. (Mines cannot be on ships)`;
                    } else if (!myPlayer.ready) {
                        gameStatus.textContent = "Ready Up!";
                        setupInstructions.textContent = `You are all set! Hit the Ready button.`;
                    } else {
                        gameStatus.textContent = "Waiting for others...";
                        setupInstructions.textContent = `Waiting for other players to get ready...`;
                    }
                    
                    readyButton.disabled = (myPlayer.shipsPlaced !== SHIP_COUNT) || (myPlayer.minesPlaced !== MINE_COUNT) || myPlayer.ready;
                    
                    chatControls.classList.remove('hidden'); // Show chat
                    myGridContainer.innerHTML = createGridHTML(myPlayer, true, false);
                    break;
                    
                case "playing":
                    const currentPlayer = roomData.players[roomData.currentPlayerIndex];
                    const isMyTurn = currentPlayer.userId === userId;
                    
                    if (isMyTurn) {
                        if (myPlayer.isSkippingTurn) {
                            gameStatus.textContent = "You hit a mine! Skipping your turn...";
                            gameStatus.classList.add('text-red-500');
                            // Skip turn immediately
                            setTimeout(handleSkipTurn, 2000); // 2s delay to show message
                        } else {
                            if (oldLocalGameData) {
                                const oldPlayer = oldLocalGameData.players[oldLocalGameData.currentPlayerIndex];
                                if (oldPlayer?.userId !== userId) {
                                    hasMovedShipThisTurn = false;
                                }
                            }

                            opponentGridsContainer.style.pointerEvents = 'auto'; 

                            if (shipToMoveIndex !== null) {
                                calculateValidMoves(shipToMoveIndex, myPlayer.grid);
                                
                                if (myPlayer.grid[shipToMoveIndex] !== 1) {
                                    cancelMove(); 
                                    gameStatus.textContent = "Your Turn! Attack!";
                                    if (!hasMovedShipThisTurn) {
                                        gameStatus.textContent += " (Or click a ship to move)";
                                    }
                                    gameStatus.classList.add('text-yellow-500');
                                } else {
                                    gameStatus.textContent = "Move: Select an adjacent empty cell.";
                                    gameStatus.classList.add('text-yellow-500');
                                    opponentGridsContainer.style.pointerEvents = 'none'; 
                                }
                            } else {
                                gameStatus.textContent = "Your Turn! Attack!";
                                if (!hasMovedShipThisTurn) {
                                    gameStatus.textContent += " (Or click a ship to move)";
                                }
                                gameStatus.classList.add('text-yellow-500');
                            }
                        }
                    } else { 
                        gameStatus.textContent = `Waiting for ${currentPlayer.name}'s turn...`;
                        gameStatus.classList.remove('text-yellow-500', 'text-red-500');
                        hasMovedShipThisTurn = false; 
                        if (shipToMoveIndex !== null) cancelMove(); 
                    }
                    
                    chatControls.classList.remove('hidden'); // Show chat
                    myGridContainer.innerHTML = createGridHTML(myPlayer, true, false);

                    roomData.players.forEach(player => {
                        if (player.userId === userId) return; 
                        if (player.isOut) {
                            opponentGridsContainer.innerHTML += createPlayerOutHTML(player);
                        } else {
                            opponentGridsContainer.innerHTML += createGridHTML(player, false, isMyTurn && !myPlayer.isSkippingTurn && shipToMoveIndex === null);
                        }
                    });
                    break;
                    
                case "over":
                    const winner = roomData.players.find(p => p.userId === roomData.winner);
                    gameStatus.textContent = "Game Over!";
                    winnerName.textContent = winner ? winner.name : 'Unknown';
                    gameOverModal.classList.remove('hidden');
                    
                    chatControls.classList.remove('hidden'); // Show chat
                    myGridContainer.innerHTML = createGridHTML(myPlayer, true, false);
                    roomData.players.forEach(player => {
                         if (player.userId === userId) return;
                         opponentGridsContainer.innerHTML += createGridHTML(player, false, false);
                    });
                    break;
            }
        }
        
        // --- Event Handlers ---

        /**
         * Handles selecting a color in the waiting room.
         * @param {Event} e - The click event.
         */
        async function handleColorSelectInRoom(e) {
            const swatch = e.target.closest('.color-swatch');
            if (!swatch || swatch.classList.contains('disabled')) return;
            if (!localGameData || localGameData.gameState !== 'waiting') return;

            const newColor = swatch.dataset.color;
            const myPlayer = localGameData.players.find(p => p.userId === userId);

            if (myPlayer.color === newColor) return; 

            document.querySelectorAll('#room-color-picker .color-swatch').forEach(s => s.classList.remove('selected'));
            swatch.classList.add('selected');

            const newPlayers = localGameData.players.map(p => 
                p.userId === userId ? { ...p, color: newColor } : p
            );
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, { players: newPlayers });
            } catch (err) {
                console.error("Error setting color:", err);
                showMessage("Error setting color. Please try again.");
            }
        }


        async function handleCreateRoom() {
            const name = nameInput.value.trim();
            if (!name) {
                loginError.textContent = "Please enter your name.";
                return;
            }
            loginError.textContent = "";
            createRoomButton.disabled = true;
            createRoomButton.textContent = "Creating...";
            joinButton.disabled = true; 

            myPlayerName = name;
            let newRoomCode = '';
            let roomRef;
            let roomSnap;
            let attempts = 0;

            do {
                newRoomCode = generateRoomCode(5);
                currentRoomCode = newRoomCode; 
                roomRef = doc(db, getRoomPath());
                roomSnap = await getDoc(roomRef);
                attempts++;
                if (attempts > 10) { 
                    throw new Error("Failed to generate a unique room code.");
                }
            } while (roomSnap.exists());

            console.log(`Creating new room: ${newRoomCode}`);

            try {
                const newPlayer = createNewPlayer();
                const newRoomData = {
                    creatorId: userId,
                    players: [newPlayer],
                    gameState: "waiting", 
                    currentPlayerIndex: 0,
                    gameLog: [{ type: 'game', message: `${myPlayerName} created the room.` }],
                    createdAt: serverTimestamp(),
                    winner: null,
                    lastMove: null
                };
                await setDoc(roomRef, newRoomData);
                
                localStorage.setItem('savedRoomCode', currentRoomCode);
                localStorage.setItem('savedPlayerName', myPlayerName);
                
                isSpectator = false;
                showGameScreen();
                listenToRoom();
                startPresenceUpdates(); // NEW: Start updating presence

            } catch (err) {
                console.error("Error creating room:", err);
                loginError.textContent = err.message;
                createRoomButton.disabled = false;
                createRoomButton.textContent = "Create New Game";
                joinButton.disabled = false;
            }
        }

        async function handleJoinRoom(isReload = false) {
            let name, roomCode;
            
            if (isReload) {
                name = localStorage.getItem('savedPlayerName');
                roomCode = localStorage.getItem('savedRoomCode');
            } else {
                name = nameInput.value.trim();
                roomCode = roomInput.value.trim().toUpperCase();
            }

            if (!name) {
                loginError.textContent = "Please enter your name.";
                if (isReload) showLoginScreen(); // Saved data invalid
                return;
            }
            if (!roomCode || roomCode.length !== 5) { // Added !roomCode check
                loginError.textContent = "Room code must be 5 characters.";
                if (isReload) showLoginScreen(); // Saved data invalid
                return;
            }
            
            loginError.textContent = "";
            joinButton.disabled = true;
            joinButton.textContent = "Joining...";
            createRoomButton.disabled = true; 

            myPlayerName = name;
            currentRoomCode = roomCode;
            
            const roomRef = doc(db, getRoomPath());
            
            try {
                const roomSnap = await getDoc(roomRef);
                
                if (!roomSnap.exists()) {
                    if (isReload) {
                        // Room doesn't exist anymore, just go to login
                        showLoginScreen();
                        return;
                    }
                    throw new Error("Room not found. Check the code.");
                } 
                
                const roomData = roomSnap.data();
                const isRejoining = roomData.players.find(p => p.userId === userId);

                if (isRejoining) {
                    // Player rejoining, check if they are marked as 'out'
                    if (isRejoining.isOut) {
                         if (isReload) {
                            showLoginScreen(); // Was kicked/left, clear session
                            return;
                        }
                        throw new Error("You were removed from this game. You cannot rejoin.");
                    }
                    // Not out, update name and lastSeen
                    const newPlayers = roomData.players.map(p => 
                        p.userId === userId ? { ...p, name: myPlayerName, lastSeen: serverTimestamp() } : p
                    );
                    await updateDoc(roomRef, { players: newPlayers });
                    isSpectator = false;
                } else {
                    // New player joining
                    if (roomData.gameState === "waiting") {
                        if (roomData.players.length >= MAX_PLAYERS) { 
                            throw new Error(`Room is full (max ${MAX_PLAYERS} players).`);
                        }
                        const newPlayer = createNewPlayer();
                        await updateDoc(roomRef, {
                            players: arrayUnion(newPlayer),
                            gameLog: arrayUnion({ type: 'game', message: `${myPlayerName} joined the room.` })
                        });
                        isSpectator = false;
                    } else {
                        // Game in progress, join as spectator
                        isSpectator = true;
                        // Don't save session for spectators
                        localStorage.removeItem('savedRoomCode');
                        localStorage.removeItem('savedPlayerName');
                        await updateDoc(roomRef, {
                             gameLog: arrayUnion({ type: 'game', message: `${myPlayerName} joined as a spectator.` })
                        });
                    }
                }
                
                if (!isReload && !isSpectator) { // Don't save for spectators
                    localStorage.setItem('savedRoomCode', currentRoomCode);
                    localStorage.setItem('savedPlayerName', myPlayerName);
                }
                
                showGameScreen();
                listenToRoom();
                if (!isSpectator) startPresenceUpdates(); // NEW: Start presence if not spectator
                
            } catch (err) {
                console.error("Error joining room:", err);
                if (isReload) {
                    showLoginScreen();
                } else {
                    loginError.textContent = err.message;
                    joinButton.disabled = false;
                    joinButton.textContent = "Join Game";
                    createRoomButton.disabled = false;
                }
            }
        }
        
        async function handleStartGame() {
            if (!localGameData) return;
            // Check only active (not isOut) players for count and color
            const activePlayers = localGameData.players.filter(p => !p.isOut); 
            if (activePlayers.length < 2) {
                startGameError.textContent = "Need at least 2 active players to start.";
                return;
            }

            if (activePlayers.some(p => p.color === null)) {
                 startGameError.textContent = "All active players must choose a color before starting.";
                 return;
            }
            
            startGameError.textContent = "";
            startGameButton.disabled = true;
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    gameState: "setup",
                    gameLog: arrayUnion({ type: 'game', message: "The game is starting! Place your items." })
                });
            } catch (err) {
                console.error("Error starting game:", err);
                startGameError.textContent = "Error starting game. Please try again.";
                startGameButton.disabled = false;
            }
        }
        
        
        /**
         * Handles clicking on a grid cell (for setup, moving, or attacking).
         * @param {Event} e - The click event.
         */
        function handleGridClick(e) {
            const cellEl = e.target.closest('.grid-cell');
            if (!cellEl) return;
            if (!localGameData || isSpectator) return; // Spectators can't click grids
            
            const kickButton = e.target.closest('.kick-button-ingame');
            if (kickButton) {
                handleKickOrExit(e, 'kick');
                return;
            }
            
            const row = parseInt(cellEl.dataset.row);
            const col = parseInt(cellEl.dataset.col);
            if (isNaN(row) || isNaN(col)) return; 
            
            const index = toIndex(row, col);
            
            // Ensure currentPlayerIndex is valid before accessing players array
             if (localGameData.currentPlayerIndex < 0 || localGameData.currentPlayerIndex >= localGameData.players.length) {
                console.error("Invalid currentPlayerIndex:", localGameData.currentPlayerIndex);
                return; // Or handle appropriately, e.g., reset game state if needed
            }
            const currentPlayer = localGameData.players[localGameData.currentPlayerIndex];
            const isMyTurn = localGameData.gameState === 'playing' && currentPlayer.userId === userId;

            // --- Move Ship Logic ---
            if (isMyTurn && cellEl.closest('.my-grid') && !currentPlayer.isSkippingTurn) {
                const myPlayer = localGameData.players.find(p => p.userId === userId);

                if (validMoveIndices.includes(index)) {
                    executeSilentMove(shipToMoveIndex, index);
                    return; 
                }

                if (!hasMovedShipThisTurn && myPlayer.grid[index] === 1 && index !== shipToMoveIndex) { 
                    cancelMove(); 
                    shipToMoveIndex = index;
                    calculateValidMoves(index, myPlayer.grid);
                    renderGameUI(localGameData); 
                    return; 
                }
                
                if (shipToMoveIndex !== null) {
                    cancelMove();
                    renderGameUI(localGameData);
                    return;
                }
            }

            // --- Setup Logic ---
            if (localGameData.gameState === 'setup') {
                const myPlayer = localGameData.players.find(p => p.userId === userId);
                if (myPlayer.ready) return; 
                if (cellEl.closest('.my-grid')) {
                    handleSetupClick(index);
                }
            } 
            // --- Attack Logic ---
            else if (isMyTurn && cellEl.closest('.opponent-grid') && !currentPlayer.isSkippingTurn) {
                if (shipToMoveIndex === null) {
                    handleAttackClick(cellEl.dataset.playerId, index);
                } else {
                    cancelMove();
                    renderGameUI(localGameData);
                }
            }
        }

        /**
         * Handles placing/removing a ship during setup.
         * @param {number} index - The cell index clicked (0-35).
         */
        async function handleSetupClick(index) {
            // FIX: Optimistic UI Update
            if (!localGameData) return;
            const myPlayer = localGameData.players.find(p => p.userId === userId);
            if (!myPlayer || myPlayer.ready) return;

            let newGrid = [...myPlayer.grid];
            let newShipsPlaced = myPlayer.shipsPlaced;
            let newMinesPlaced = myPlayer.minesPlaced;
            
            const currentCell = newGrid[index];
            
            if (newShipsPlaced < SHIP_COUNT) {
                // Placing ships
                if (currentCell === 0) {
                    newGrid[index] = 1; // Place ship
                    newShipsPlaced++;
                } else if (currentCell === 1) {
                    newGrid[index] = 0; // Remove ship
                    newShipsPlaced--;
                }
            } else if (newMinesPlaced < MINE_COUNT) {
                // Placing mines
                if (currentCell === 0) {
                    newGrid[index] = 2; // Place mine
                    newMinesPlaced++;
                } else if (currentCell === 2) {
                    newGrid[index] = 0; // Remove mine
                    newMinesPlaced--;
                } else if (currentCell === 1) {
                    showMessage("Cannot place a mine on a ship!");
                }
            } else if (currentCell === 1) {
                // All items placed, can only remove ships
                newGrid[index] = 0;
                newShipsPlaced--;
            } else if (currentCell === 2) {
                 // All items placed, can only remove mines
                newGrid[index] = 0;
                newMinesPlaced--;
            } else {
                return; // Clicked on invalid spot
            }

            // Optimistically update local data and re-render
            const newPlayers = localGameData.players.map(p => 
                p.userId === userId ? { ...p, grid: newGrid, shipsPlaced: newShipsPlaced, minesPlaced: newMinesPlaced } : p
            );
            localGameData.players = newPlayers;
            renderGameUI(localGameData); // Re-render immediately
            
            // Update Firestore in the background
            const roomRef = doc(db, getRoomPath());
            try {
                // Note: We only update 'players', not the whole localGameData
                await updateDoc(roomRef, { players: newPlayers });
            } catch (err) {
                console.error("Error placing item:", err);
                showMessage("Error placing item. Please try again.");
                // TODO: Consider a rollback, but for setup it's low-risk
            }
        }

        /**
         * Handles the "Ready" button click.
         */
        async function handleReadyClick() {
            readyButton.disabled = true;
            
            const myPlayer = localGameData.players.find(p => p.userId === userId);
            if (myPlayer.shipsPlaced !== SHIP_COUNT || myPlayer.minesPlaced !== MINE_COUNT) { 
                 showMessage(`You must place all ${SHIP_COUNT} ships and ${MINE_COUNT} mines.`);
                 readyButton.disabled = false;
                 return;
            }

            const newPlayers = localGameData.players.map(p =>
                p.userId === userId ? { ...p, ready: true } : p
            );
            
            // Check only players who are not 'out'
            const allReady = newPlayers.filter(p => !p.isOut).every(p => p.ready);
            
            const roomRef = doc(db, getRoomPath());
            try {
                if (allReady) {
                    await updateDoc(roomRef, {
                        players: newPlayers,
                        gameState: "playing",
                        currentPlayerIndex: 0, // Ensure starting player is valid
                        gameLog: arrayUnion({ type: 'game', message: "All players are ready! The battle begins!" })
                    });
                } else {
                    await updateDoc(roomRef, { players: newPlayers });
                }
            } catch (err) {
                console.error("Error setting ready status:", err);
                showMessage("Error. Please try again.");
                readyButton.disabled = false;
            }
        }

        /**
         * Handles an attack on an opponent.
         * @param {string} targetPlayerId - The ID of the player being attacked.
         * @param {number} cellIndex - The cell index being attacked (0-35).
         */
        async function handleAttackClick(targetPlayerId, cellIndex) {
            cancelMove();
            opponentGridsContainer.style.pointerEvents = 'none';

            // Ensure currentPlayerIndex is valid before accessing players array
            if (localGameData.currentPlayerIndex < 0 || localGameData.currentPlayerIndex >= localGameData.players.length) {
                console.error("Invalid currentPlayerIndex before attack:", localGameData.currentPlayerIndex);
                opponentGridsContainer.style.pointerEvents = 'auto'; // Re-enable clicks
                return; 
            }
            const attacker = localGameData.players[localGameData.currentPlayerIndex];
            const targetPlayer = localGameData.players.find(p => p.userId === targetPlayerId);
            
            if (typeof targetPlayer.grid[cellIndex] === 'object') {
                showMessage("That position has already been attacked!");
                opponentGridsContainer.style.pointerEvents = 'auto'; 
                return;
            }
            
            const targetCell = targetPlayer.grid[cellIndex];
            const wasHit = targetCell === 1;
            const wasMine = targetCell === 2;
            const coord = toGridCoord(cellIndex);
            
            let logMsg = { type: 'game', message: "" };
            let newLogMessages = [];
            
            let newPlayers = [...localGameData.players];
            let newGameState = localGameData.gameState;
            let newWinner = null;
            let nextPlayerIndex = localGameData.currentPlayerIndex;
            
            const attackerColor = attacker.color || DEFAULT_COLOR; 
            const newGrid = [...targetPlayer.grid];
            let newShipsLeft = targetPlayer.shipsLeft;
            let newIsOut = targetPlayer.isOut;

            if (wasHit) {
                logMsg.message = `${attacker.name} attacked ${targetPlayer.name} at ${coord}... HIT! 🚢`;
                newGrid[cellIndex] = { type: 'hit', attackerId: attacker.userId, attackerColor: attackerColor };
                newShipsLeft--;
                if (newShipsLeft === 0) {
                    newIsOut = true;
                    newLogMessages.push({ type: 'game', message: `${targetPlayer.name} has been eliminated!` });
                }
            } else if (wasMine) {
                logMsg.message = `${attacker.name} attacked ${targetPlayer.name} at ${coord}... IT'S A MINE! 💥`;
                newGrid[cellIndex] = { type: 'mine-hit', attackerId: attacker.userId, attackerColor: attackerColor };
                
                newPlayers = newPlayers.map(p => 
                    p.userId === attacker.userId ? { ...p, isSkippingTurn: true } : p
                );
                newLogMessages.push({ type: 'game', message: `${attacker.name} hit a mine and will skip their next turn!` });
            } else {
                logMsg.message = `${attacker.name} attacked ${targetPlayer.name} at ${coord}... MISS! X`;
                newGrid[cellIndex] = { type: 'miss', attackerId: attacker.userId, attackerColor: attackerColor };
            }
            
            newLogMessages.unshift(logMsg);
            
            newPlayers = newPlayers.map(p => 
                p.userId === targetPlayerId ? { ...p, grid: newGrid, shipsLeft: newShipsLeft, isOut: newIsOut } : p
            );

            // Check for game over
            const playersStillIn = newPlayers.filter(p => !p.isOut);
            if (playersStillIn.length === 1) {
                newGameState = "over";
                newWinner = playersStillIn[0].userId;
                newLogMessages.push({ type: 'game', message: `GAME OVER! ${playersStillIn[0].name} is the winner!` });
            } else if (playersStillIn.length === 0) {
                newGameState = "over";
                newLogMessages.push({ type: 'game', message: "GAME OVER! It's a draw!" });
            }
            
            // Determine next turn
            if (newGameState === "playing" && !wasHit) { // Turn advances on miss or mine hit
                 // Ensure there are active players before trying to find the next one
                if (playersStillIn.length > 0) {
                    do {
                        nextPlayerIndex = (nextPlayerIndex + 1) % newPlayers.length;
                    } while (newPlayers[nextPlayerIndex].isOut);
                } else {
                    // No players left, shouldn't happen if game over check is correct, but safety first
                    nextPlayerIndex = -1; // Or handle as appropriate
                }
            } else if (newGameState === "playing" && wasHit) {
                 // Hit, turn does not advance, but check if current player is still valid
                 if (nextPlayerIndex < 0 || nextPlayerIndex >= newPlayers.length || newPlayers[nextPlayerIndex].isOut) {
                      // If the current player got eliminated on their turn (unlikely but possible with self-hit logic?), find next
                      if (playersStillIn.length > 0) {
                            do {
                                nextPlayerIndex = (nextPlayerIndex + 1) % newPlayers.length;
                            } while (newPlayers[nextPlayerIndex].isOut);
                       } else {
                           nextPlayerIndex = -1;
                       }
                 }
            }
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    players: newPlayers,
                    gameState: newGameState,
                    winner: newWinner,
                    currentPlayerIndex: nextPlayerIndex,
                    gameLog: arrayUnion(...newLogMessages),
                    lastMove: { playerId: targetPlayerId, cellIndex: cellIndex }
                });
            } catch (err) {
                console.error("Error during attack:", err);
                showMessage("Error processing attack. Please try again.");
                // Ensure clicks are re-enabled if the update fails
                opponentGridsContainer.style.pointerEvents = 'auto'; 
            } 
        }

        /**
         * Handles the automatic turn skip after hitting a mine.
         */
        async function handleSkipTurn() {
            if (!localGameData) return;
            
             // Ensure currentPlayerIndex is valid before accessing players array
            if (localGameData.currentPlayerIndex < 0 || localGameData.currentPlayerIndex >= localGameData.players.length) {
                console.error("Invalid currentPlayerIndex during skip:", localGameData.currentPlayerIndex);
                return; 
            }
            const currentPlayer = localGameData.players[localGameData.currentPlayerIndex];
            // Only the player whose turn it is should execute this
            if (currentPlayer.userId !== userId || !currentPlayer.isSkippingTurn) return; 

            let newPlayers = localGameData.players.map(p => 
                p.userId === userId ? { ...p, isSkippingTurn: false } : p
            );
            
            // Find next player
            let nextPlayerIndex = localGameData.currentPlayerIndex;
            const playersStillIn = newPlayers.filter(p => !p.isOut);

             if (playersStillIn.length > 0) {
                do {
                    nextPlayerIndex = (nextPlayerIndex + 1) % newPlayers.length;
                } while (newPlayers[nextPlayerIndex].isOut);
            } else {
                nextPlayerIndex = -1; // No active players left
            }
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    players: newPlayers,
                    currentPlayerIndex: nextPlayerIndex,
                    gameLog: arrayUnion({ type: 'game', message: `${myPlayerName} skipped their turn.` })
                });
            } catch (err) {
                console.error("Error skipping turn:", err);
            }
        }


        /**
         * Handles sending a chat message.
         */
        async function handleSendChat() {
            const message = chatInput.value.trim();
            if (!message) return;
            if (!localGameData || isSpectator) return; // Spectators can't chat

            chatInput.disabled = true;
            chatSendButton.disabled = true;

            const myPlayer = localGameData.players.find(p => p.userId === userId);
            const myColor = myPlayer?.color || DEFAULT_COLOR;
            const myName = myPlayerName; 

            const chatObject = { 
                type: 'chat', 
                name: myName, 
                color: myColor, 
                message: message 
            };

            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, { 
                    gameLog: arrayUnion(chatObject) 
                });
                chatInput.value = ''; // Clear input on success
            } catch (err) {
                console.error("Error sending chat:", err);
                showMessage("Error sending message. Please try again.");
            } finally {
                chatInput.disabled = false;
                chatSendButton.disabled = false;
                chatInput.focus();
            }
        }
        
        // --- REVISED: Ship Moving Functions ---

        /**
         * Calculates valid adjacent move destinations.
         * @param {number} fromIndex - The grid index to move from.
         * @param {Array} grid - The player's grid.
         */
        function calculateValidMoves(fromIndex, grid) {
            validMoveIndices = [];
            const { row, col } = toRowCol(fromIndex);
            
            const potentialMoves = [
                { r: row - 1, c: col }, // Up
                { r: row + 1, c: col }, // Down
                { r: row, c: col - 1 }, // Left
                { r: row, c: col + 1 }  // Right
            ];

            for (const move of potentialMoves) {
                if (move.r >= 0 && move.r < GRID_SIZE && move.c >= 0 && move.c < GRID_SIZE) {
                    const toIndex = toIndex(move.r, move.c);
                    if (grid[toIndex] === 0) {
                        validMoveIndices.push(toIndex);
                    }
                }
            }
        }

        /**
         * Cancels the "Move Ship" state.
         */
        function cancelMove() {
            shipToMoveIndex = null;
            validMoveIndices = [];
        }

        /**
         * Executes a silent ship move. Does NOT cost a turn.
         * @param {number} fromIndex - The grid index to move from.
         * @param {number} toIndex - The grid index to move to.
         */
        async function executeSilentMove(fromIndex, toIndex) {
            gameStatus.textContent = "Moving ship...";
            myGridContainer.style.pointerEvents = 'none'; 

            const myPlayer = localGameData.players.find(p => p.userId === userId);
            let newGrid = [...myPlayer.grid];
            newGrid[fromIndex] = 0; 
            newGrid[toIndex] = 1;   

            let newPlayers = localGameData.players.map(p => 
                p.userId === userId ? { ...p, grid: newGrid } : p
            );
            
            const oldLocalData = localGameData; // Keep a copy in case of error
            localGameData.players = newPlayers;
            hasMovedShipThisTurn = true;
            cancelMove(); 
            renderGameUI(localGameData); // Re-render immediately
            myGridContainer.style.pointerEvents = 'auto'; // Re-enable

            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    players: newPlayers
                });
            } catch (err) {
                console.error("Error moving ship:", err);
                showMessage("Error moving ship. Reverting move.");
                localGameData = oldLocalData;
                hasMovedShipThisTurn = false;
                renderGameUI(localGameData);
            }
        }
        
        /**
         * Handles kicking a player (from any state) or exiting.
         * @param {Event} e - The click event.
         */
        async function handleKickOrExit(e, exitType) {
            let kickId;
            let logMessage;
            
            if (exitType === 'kick') {
                kickId = e.target.dataset.kickId;
                if (!kickId || !localGameData) return; // Allow anyone to kick disconnected, host check later

                 const targetPlayer = localGameData.players.find(p => p.userId === kickId);
                 const isCreator = localGameData.creatorId === userId;
                 const isDisconnected = disconnectedPlayers[kickId];
                 const canKickDisconnected = isDisconnected && (Date.now() - disconnectedPlayers[kickId] > KICK_TIMEOUT);

                 // Only allow kick if host OR target is disconnected long enough
                 if (!isCreator && !canKickDisconnected) {
                     showMessage("Only the host can kick active players.");
                     return;
                 }

            } else {
                // Self-exit
                kickId = userId;
            }
            
            const kickedPlayer = localGameData.players.find(p => p.userId === kickId);
            if (!kickedPlayer || kickedPlayer.isOut) return; // Can't kick someone already out

            // Mark player as 'out'. Don't remove, to preserve scores/grids.
            let newPlayers = localGameData.players.map(p => 
                p.userId === kickId ? { ...p, isOut: true, shipsLeft: 0 } : p
            );

            if (exitType === 'kick') {
                logMessage = { type: 'game', message: `${kickedPlayer.name} was kicked.` };
            } else {
                logMessage = { type: 'game', message: `${kickedPlayer.name} left the game.` };
            }

            let newGameState = localGameData.gameState;
            let newWinner = null;
            let newPlayerIndex = localGameData.currentPlayerIndex;
            
            // Check for game over
            const playersStillIn = newPlayers.filter(p => !p.isOut);
            if (newGameState !== 'waiting' && newGameState !== 'setup') {
                if (playersStillIn.length === 1) {
                    newGameState = "over";
                    newWinner = playersStillIn[0].userId;
                    // Adjust log message for automatic win
                    const winnerName = playersStillIn[0].name; 
                    logMessage = { type: 'game', message: `${kickedPlayer.name} left. ${winnerName} is the winner!` };
                } else if (playersStillIn.length === 0) {
                    newGameState = "over";
                    logMessage = { type: 'game', message: "Everyone left. It's a draw!" };
                }
            }

            // Advance turn if the kicked player was the current player
            if (newGameState === 'playing' && playersStillIn.length > 0 && localGameData.players[newPlayerIndex]?.userId === kickId) {
                 do {
                    newPlayerIndex = (newPlayerIndex + 1) % newPlayers.length;
                } while (newPlayers[newPlayerIndex].isOut);
            } else if (playersStillIn.length === 0 && newGameState === 'playing') {
                 newPlayerIndex = -1; // No valid players left
            }
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, { 
                    players: newPlayers,
                    gameLog: arrayUnion(logMessage),
                    gameState: newGameState,
                    winner: newWinner,
                    currentPlayerIndex: newPlayerIndex
                });
                
                if (exitType === 'exit') {
                    showLoginScreen(); // Go to login screen after self-exit
                }
                
            } catch (err) {
                console.error("Error kicking/exiting player:", err);
                showMessage("Error removing player. Please try again.");
            }
        }


        // --- Screen Management ---
        
        function showLoginScreen() {
            loadingScreen.classList.add('hidden');
            gameScreen.classList.add('hidden');
            loginScreen.classList.remove('hidden');
            exitRoomButton.classList.add('hidden');
            
            localStorage.removeItem('savedRoomCode');
            localStorage.removeItem('savedPlayerName');
            
            if (unsubscribeRoom) {
                unsubscribeRoom();
                unsubscribeRoom = null;
            }
            if (presenceIntervalId) { // NEW: Clear presence interval
                clearInterval(presenceIntervalId);
                presenceIntervalId = null;
            }
            
            localGameData = null;
            oldLocalGameData = null;
            currentRoomCode = null;
            isSpectator = false;
            disconnectedPlayers = {}; // NEW: Clear disconnect tracker
            cancelMove(); 
            hasMovedShipThisTurn = false; 
            
            joinButton.disabled = false;
            joinButton.textContent = "Join Game";
            createRoomButton.disabled = false;
            createRoomButton.textContent = "Create New Game";
        }
        
        function showGameScreen() {
            loadingScreen.classList.add('hidden');
            loginScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            exitRoomButton.classList.remove('hidden');
        }

        // --- Firebase Initialization ---

        async function signIn() {
            try {
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Firebase Sign-In Error:", error);
                loadingScreen.innerHTML = "<h1>Auth Error</h1><p>Could not sign in. Check console and Firebase settings.</p>";
            }
        }
        
         /**
         * NEW: Starts periodically updating the player's lastSeen timestamp.
         */
        function startPresenceUpdates() {
            if (presenceIntervalId) clearInterval(presenceIntervalId); // Clear existing timer
            
            const updatePresence = async () => {
                const roomPath = getRoomPath();
                if (!roomPath || !localGameData) return; // Don't update if not in a room

                const myPlayerIndex = localGameData.players.findIndex(p => p.userId === userId);
                if (myPlayerIndex === -1 || localGameData.players[myPlayerIndex].isOut) {
                    // Player not found or is out, stop updates
                    if (presenceIntervalId) clearInterval(presenceIntervalId);
                    return;
                }

                const roomRef = doc(db, roomPath);
                try {
                     // Use a specific field update to avoid overwriting other player data
                    await updateDoc(roomRef, {
                        [`players.${myPlayerIndex}.lastSeen`]: serverTimestamp()
                    });
                     console.log("Presence updated");
                } catch (err) {
                    console.error("Error updating presence:", err);
                    // Consider stopping updates if there's a persistent error
                }
            };

            // Update immediately first time
            updatePresence(); 
            // Then update periodically
            presenceIntervalId = setInterval(updatePresence, PRESENCE_UPDATE_INTERVAL);
        }

        /**
         * Main room listener. Handles game state.
         */
        function listenToRoom() {
            if (unsubscribeRoom) {
                unsubscribeRoom();
            }
            
            const roomPath = getRoomPath();
             if (!roomPath) { // Safety check if room code is lost
                showLoginScreen();
                return;
            }
            const roomRef = doc(db, roomPath);

            unsubscribeRoom = onSnapshot(roomRef, (doc) => {
                if (doc.exists()) {
                    oldLocalGameData = localGameData; // Save previous state
                    localGameData = doc.data();
                    
                    let shouldAddDisconnectLog = []; // Track who needs a log message THIS snapshot

                    // --- Disconnect Check ---
                    if (localGameData.players) {
                        const now = Date.now();
                        localGameData.players.forEach(player => {
                            if (player.userId === userId || player.isOut) {
                                // Ignore self or players already out
                                if (disconnectedPlayers[player.userId]) {
                                    delete disconnectedPlayers[player.userId]; // Clear if they rejoined or are out
                                }
                                return; 
                            }

                            if (player.lastSeen instanceof Timestamp) {
                                const lastSeenTime = player.lastSeen.toDate().getTime();
                                if (now - lastSeenTime > DISCONNECT_TIMEOUT) {
                                    // Player is disconnected
                                    if (!disconnectedPlayers[player.userId]) {
                                        // First time seeing disconnect for this player
                                        disconnectedPlayers[player.userId] = now; // Store time detected
                                        shouldAddDisconnectLog.push(player.name);
                                        console.log(`${player.name} detected as disconnected.`);
                                    }
                                } else {
                                    // Player is connected or reconnected
                                    if (disconnectedPlayers[player.userId]) {
                                        delete disconnectedPlayers[player.userId];
                                        console.log(`${player.name} reconnected.`);
                                         // Optionally add a reconnect message to log here
                                    }
                                }
                            } else {
                                // lastSeen is not a timestamp yet (might be serverTimestamp placeholder)
                                // Or player object is malformed
                                console.warn("Player missing valid lastSeen:", player.name);
                            }
                        });
                    }
                    
                    // Add disconnect messages if needed (do this outside the loop)
                    if (shouldAddDisconnectLog.length > 0) {
                        const logMessages = shouldAddDisconnectLog.map(name => ({
                            type: 'game', message: `${name} appears to have disconnected.`
                        }));
                        // Update log in Firestore (don't await, let snapshot handle UI)
                        updateDoc(roomRef, { gameLog: arrayUnion(...logMessages) })
                            .catch(err => console.error("Error adding disconnect log:", err));
                    }


                    // --- Continue with normal state processing ---
                    if (!isSpectator) {
                        const myPlayer = localGameData.players.find(p => p.userId === userId);
                        if (!myPlayer) {
                            showMessage("You were removed from the room.");
                            showLoginScreen();
                            return;
                        }
                        
                        if (myPlayer.isOut) {
                            showMessage("You have been eliminated or removed from the game.");
                            showLoginScreen();
                            return;
                        }
                        
                        if (oldLocalGameData) {
                             // Ensure index is valid before checking
                             if(oldLocalGameData.currentPlayerIndex >= 0 && oldLocalGameData.currentPlayerIndex < oldLocalGameData.players.length) {
                                const oldPlayerIndex = oldLocalGameData.currentPlayerIndex;
                                const newPlayerIndex = localGameData.currentPlayerIndex;
                                const myPlayerIndex = localGameData.players.findIndex(p => p.userId === userId);
                                
                                if (oldPlayerIndex === myPlayerIndex && newPlayerIndex !== myPlayerIndex) {
                                    hasMovedShipThisTurn = false;
                                    cancelMove(); 
                                }
                            }
                        }
                    }

                    opponentGridsContainer.style.pointerEvents = 'auto';
                    myGridContainer.style.pointerEvents = 'auto';
                    
                    renderGameUI(localGameData); // Render based on potentially updated disconnect status

                    if (!isSpectator && localGameData.gameState === 'playing') {
                        // Ensure currentPlayerIndex is valid
                        if (localGameData.currentPlayerIndex >= 0 && localGameData.currentPlayerIndex < localGameData.players.length) {
                            const currentPlayer = localGameData.players[localGameData.currentPlayerIndex];
                            const isMyTurn = currentPlayer.userId === userId;
                            if (isMyTurn) {
                                if(currentPlayer.isSkippingTurn) {
                                    opponentGridsContainer.style.pointerEvents = 'none';
                                    myGridContainer.style.pointerEvents = 'none';
                                } else if (shipToMoveIndex !== null) {
                                    opponentGridsContainer.style.pointerEvents = 'none';
                                }
                            }
                        } else {
                             console.warn("Current player index out of bounds in 'playing' state:", localGameData.currentPlayerIndex);
                        }
                    }

                    if (oldLocalGameData?.gameState !== 'over' && localGameData.gameState === 'over') {
                        setTimeout(() => {
                            gameOverModal.classList.remove('hidden');
                        }, 1000);
                    }
                } else {
                    showMessage("The game room no longer exists.");
                    showLoginScreen();
                }
            }, (error) => {
                console.error("Firestore Snapshot Error:", error);
                showMessage("Lost connection to game room.");
                showLoginScreen();
            });
        }
        
        window.onload = () => {
            if (!firebaseConfig.apiKey || !firebaseConfig.projectId) {
                 loadingScreen.innerHTML = "<h1>Error</h1><p>Firebase is not configured. Please paste your `firebaseConfig` object into the script.</p>";
                return;
            }
            
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug'); 

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated with userId:", userId);
                        
                        const savedRoomCode = localStorage.getItem('savedRoomCode');
                        const savedPlayerName = localStorage.getItem('savedPlayerName');
                        
                        if (savedRoomCode && savedPlayerName) {
                            console.log(`Found saved session: ${savedPlayerName} in ${savedRoomCode}`);
                            handleJoinRoom(true); // Attempt to rejoin
                        } else {
                            showLoginScreen(); 
                        }
                        
                    } else {
                        console.log("User is not authenticated. Attempting sign-in...");
                        signIn();
                    }
                });

                // --- Bind Event Listeners ---
                createRoomButton.addEventListener('click', handleCreateRoom);
                joinButton.addEventListener('click', () => handleJoinRoom(false));
                startGameButton.addEventListener('click', handleStartGame);
                exitRoomButton.addEventListener('click', (e) => handleKickOrExit(e, 'exit'));
                
                myGridContainer.addEventListener('click', handleGridClick);
                opponentGridsContainer.addEventListener('click', handleGridClick); // Handles in-game kick too
                
                readyButton.addEventListener('click', handleReadyClick);
                
                roomColorPicker.addEventListener('click', handleColorSelectInRoom); 
                playerListContainer.addEventListener('click', (e) => { // Handles waiting room kick
                    if (e.target.classList.contains('kick-button')) {
                        handleKickOrExit(e, 'kick');
                    }
                });
                
                chatSendButton.addEventListener('click', handleSendChat);
                chatInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') {
                        handleSendChat();
                    }
                });
                
                messageOkButton.addEventListener('click', () => {
                    messageModal.classList.add('hidden');
                });
                
                // FIX: Correctly bind playAgainButton listener
                playAgainButton.addEventListener('click', showLoginScreen); 

                roomInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') joinButton.click();
                });

            } catch (err) {
                console.error("Firebase Init Error:", err);
                loadingScreen.innerHTML = "<h1>Error</h1><p>Could not initialize the application.</p>";
            }
        };

    </script>
</body>
</html>


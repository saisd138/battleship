<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battleship Royale</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- REMOVED PeerJS Library -->
    <style>
        /* Custom game-specific styles */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Constants for grid size - MOBILE FIRST */
        :root {
            --grid-size: 6;
            --cell-size: 20px; /* Mobile size */
            --label-size: 20px; /* Mobile size */
        }
        
        /* Desktop grid sizes */
        @media (min-width: 640px) {
            :root {
                --cell-size: 35px; /* Desktop size */
                --label-size: 5px; /* Desktop size */
            }
        }

        /* Base cell style */
        .grid-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: #cce7ff; /* light-blue-100 */
            border: 1px solid #a3d5ff; /* light-blue-200 */
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; /* Mobile font size */
            font-weight: bold;
            transition: all 0.15s ease-in-out;
            position: relative;
        }
        @media (min-width: 640px) {
            .grid-cell {
                font-size: 1rem; /* Desktop font size */
            }
        }


        /* Row/Col labels */
        .grid-label {
            width: var(--label-size);
            height: var(--label-size);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.625rem; /* Mobile font size */
            font-weight: 600;
            color: #6b7280; /* gray-500 */
        }
        @media (min-width: 640px) {
            .grid-label {
                font-size: 0.75rem; /* Desktop font size */
            }
        }

        .grid-wrapper {
            display: grid;
            /* 1 label + 6 cells */
            grid-template-columns: var(--label-size) repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: var(--label-size) repeat(var(--grid-size), var(--cell-size));
            gap: 2px;
        }

        /* My grid: hover effect */
        .my-grid .grid-cell:not(.ship):not(.miss):not(.hit):not(.ship-selected-for-move):not(.move-option):not(.mine):hover {
            background-color: #a3d5ff; /* light-blue-200 */
        }
        
        /* My grid: placed ship */
        .my-grid .grid-cell.ship {
            background-color: #4b5563; /* gray-600 */
            border-color: #374151; /* gray-700 */
        }
        
        /* NEW: My grid: placed mine */
        .my-grid .grid-cell.mine {
            background-color: #cce7ff; /* light-blue-100 */
            border-color: #a3d5ff;
            color: #f97316; /* orange-500 */
        }

        /* Opponent grid: fog of war (looks default) */
        .opponent-grid .grid-cell.ship,
        .opponent-grid .grid-cell.mine {
            background-color: #cce7ff; /* light-blue-100 */
            cursor: not-allowed;
        }

        /* Opponent grid: active turn hover effect */
        .opponent-grid.turn-active .grid-cell:not(.miss):not(.hit):not(.mine-hit):hover {
            background-color: #fef08a; /* yellow-200 */
            border-color: #fde047; /* yellow-300 */
        }
        
        /* All grids: miss */
        .grid-cell.miss {
            cursor: not-allowed;
            /* Color is set by JS */
        }
        
        /* All grids: hit */
        .grid-cell.hit {
            /* Background-color is set by JS */
            border-color: #4b5563; /* gray-600 */
            cursor: not-allowed;
            animation: hit-animation 0.5s ease;
            color: #1f2937; /* gray-800 */
        }
        
        /* NEW: All grids: mine hit */
        .grid-cell.mine-hit {
            /* Background-color is set by JS */
            border-color: #ef4444; /* red-500 */
            cursor: not-allowed;
            animation: hit-animation 0.5s ease;
            color: #7f1d1d; /* red-900 */
        }
        
        @keyframes hit-animation {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Style for ship selected to be moved */
        .grid-cell.ship-selected-for-move {
            background-color: #fef08a; /* yellow-200 */
            border-color: #fde047; /* yellow-300 */
            box-shadow: 0 0 10px #fde047;
        }

        /* NEW: Style for valid move options */
        .grid-cell.move-option {
            background-color: #cce7ff;
            border: 2px dashed #facc15; /* yellow-400 */
            cursor: pointer;
        }
        .grid-cell.move-option:hover {
            background-color: #fef9c3; /* yellow-100 */
        }

        /* Player card when out */
        .player-out-card {
            background-color: #f3f4f6; /* gray-100 */
            border: 2px dashed #fca5a5; /* red-300 */
            color: #9ca3af; /* gray-400 */
            
            /* Sizing for Mobile (20*7 + 2*6 + 16*2) = 140+12+32 = 184px */
            width: 173px; 
            height: 221px; /* (20*7 + 2*6 + 16*2 + 18+20) ~ 221 */

            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }
        
        /* Sizing for Desktop */
        @media (min-width: 640px) {
            .player-out-card {
                width: 289px; /* (35*7 + 2*6 + 16*2) = 245+12+32 = 289 */
                height: 385px;
                padding: 16px;
            }
        }


        /* Modal backdrop */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.25);
        }

        /* Color picker */
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.15s ease;
        }
        .color-swatch.selected {
            border-color: #2563eb; /* blue-600 */
            box-shadow: 0 0 0 3px #fff;
        }
        .color-swatch:hover:not(.disabled) {
            opacity: 0.8;
        }
        .color-swatch.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            position: relative;
        }
        /* "X" mark for disabled colors */
        .color-swatch.disabled::before,
        .color-swatch.disabled::after {
            position: absolute;
            content: '';
            width: 70%;
            height: 2px;
            background-color: #4b5563;
            top: 50%;
            left: 15%;
            transform: rotate(45deg);
        }
        .color-swatch.disabled::after {
            transform: rotate(-45deg);
        }

        /* NEW: Game event log messages */
        .log-game-event {
            color: #DC2626; /* red-600 */
            font-style: italic;
            font-size: 0.875rem; /* text-sm */
        }
        
        /* NEW: Chat messages */
        .log-chat-message {
            font-size: 0.875rem; /* text-sm */
            word-break: break-word; /* Ensure long messages wrap */
        }


    </style>
</head>
<body class="bg-gray-50 text-gray-900 min-h-screen p-4 sm:p-6">

    <!-- Main Game Container -->
    <div id="app-container" class="max-w-screen-2xl mx-auto">

        <!-- Loading Screen -->
        <div id="loading-screen" class="text-center p-12">
            <h1 class="text-3xl font-bold text-cyan-600">Battleship Royale</h1>
            <p class="text-xl mt-4">Initializing connection...</p>
        </div>

        <!-- Login Screen -->
        <div id="login-screen" class="hidden max-w-lg mx-auto bg-white p-8 rounded-lg shadow-xl">
            <h1 class="text-3xl font-bold text-center text-cyan-600 mb-6">Battleship Royale</h1>
            
            <div class="space-y-4">
                <!-- Shared Name Input -->
                <div>
                    <label for="name-input" class="block text-sm font-medium text-gray-700 mb-1">Your Name</label>
                    <input type="text" id="name-input" class="w-full bg-white border border-gray-300 rounded-md p-3 text-gray-900 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="E.g., Captain-A">
                </div>

                <!-- Create Room -->
                <div class="border-b border-gray-200 pb-6">
                    <button id="create-room-button" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-md shadow-lg transition duration-200 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-50">
                        Create New Game
                    </button>
                </div>

                <!-- Join Room -->
                <div class="pt-4 space-y-4">
                    <p class="text-center text-gray-500 text-sm">...or join an existing game:</p>
                    <div>
                        <label for="room-input" class="block text-sm font-medium text-gray-700 mb-1">5-Character Room Code</label>
                        <input type="text" id="room-input" class="w-full bg-white border border-gray-300 rounded-md p-3 text-gray-900 font-mono uppercase focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="XYZ12" maxlength="5">
                    </div>
                    <button id="join-button" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-md shadow-lg transition duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                        Join Game
                    </button>
                </div>
                
                <p id="login-error" class="text-red-500 text-center text-sm h-4"></p>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden">
            <!-- Header -->
            <div class="bg-white p-4 rounded-lg shadow-lg mb-6 flex flex-col sm:flex-row justify-between items-center space-y-2 sm:space-y-0">
                <div class="flex items-center gap-2">
                    <span class="text-sm text-gray-500">Room:</span>
                    <span id="room-display" class="text-xl font-bold font-mono text-yellow-500"></span>
                </div>
                <!-- Voice Chat Buttons -->
                <div class="flex gap-2">
                    <button id="voice-chat-button" class="hidden bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md shadow-lg transition duration-200 text-sm">
                        Join Voice üéôÔ∏è
                    </button>
                    <button id="mute-self-button" class="hidden bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-md shadow-lg transition duration-200 text-sm">
                        Mute Self üîá
                    </button>
                </div>
                <h2 id="game-status" class="text-2xl font-bold text-center text-cyan-600">Waiting for players...</h2>
                <div>
                    <span class="text-sm text-gray-500">Player:</span>
                    <span id="my-name-display" class="text-xl font-bold text-gray-900"></span>
                </div>
            </div>

            <!-- Main Game Layout -->
            <div class="flex flex-col lg:flex-row gap-6">

                <!-- Left Column (My Grid + Setup) -->
                <div class="flex flex-col items-center lg:items-start flex-shrink-0 w-full lg:w-auto">
                    <!-- Setup Controls -->
                    <div id="setup-controls" class="hidden bg-white p-4 rounded-lg shadow-lg mb-6 text-center">
                        <h3 id="setup-instructions" class="text-xl font-semibold text-yellow-600">Place your 5 ships.</h3>
                        <p class="text-lg mt-2">
                            Ships: <span id="ships-placed-count" class="font-bold text-2xl">0</span> / 5
                            |
                            Mines: <span id="mines-placed-count" class="font-bold text-2xl">0</span> / 3
                        </p>
                        <button id="ready-button" disabled class="mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-md shadow-lg transition duration-200 disabled:bg-gray-400 disabled:cursor-not-allowed">
                            Ready
                        </button>
                    </div>

                    <!-- My Grid Container -->
                    <div id="my-grid-container" class="bg-white p-2 sm:p-4 rounded-lg shadow-lg">
                        <!-- My grid will be inserted here -->
                    </div>
                </div>

                <!-- Right Column (Opponent Grids) -->
                <div class="flex-grow min-w-0">
                    <div class="bg-white p-2 sm:p-4 rounded-lg shadow-lg h-full">
                        <h3 class="text-xl sm:text-2xl font-bold text-gray-800 mb-4 text-center sm:text-left">Opponents</h3>
                        <!-- Opponent Grids Area -->
                        <div id="opponent-grids-container" class="grid grid-cols-2 gap-2 sm:flex sm:flex-wrap sm:justify-center sm:gap-4 lg:justify-start overflow-y-auto p-1 sm:p-2 bg-gray-50 rounded-md" style="max-height: calc(100vh - 300px);">
                            <!-- Opponent grids will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Game Log (REVERSED) -->
            <div class="mt-6">
                <h3 class="text-xl font-semibold mb-2 text-gray-700">Game Log / Chat</h3>
                <!-- Chat Input (MOVED) -->
                <div id="chat-controls" class="mt-2 hidden">
                    <div class="flex gap-2">
                        <input type="text" id="chat-input" class="flex-grow bg-white border border-gray-300 rounded-md p-2 text-sm text-gray-900 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="Type a message...">
                        <button id="chat-send-button" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded-md shadow-lg transition duration-200">
                            Send
                        </button>
                    </div>
                </div>
                <!-- Log Container (MOVED) -->
                <div id="game-log-container" class="h-48 bg-gray-100 rounded-lg p-4 overflow-y-auto shadow-inner space-y-2 mt-2">
                    <!-- Log messages will be inserted here -->
                </div>
            </div>
            
            <!-- Start Game Button (for waiting room) -->
            <div id="waiting-room-controls" class="bg-white p-6 rounded-lg shadow-lg text-center mt-6">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Waiting Room</h3>
                
                <!-- Player List -->
                <div id="player-list-container" class="flex flex-wrap justify-center gap-4 mb-6">
                    <!-- Player list will be inserted here -->
                </div>
                
                <!-- Color Picker ADDED here -->
                <div class="border-t border-gray-200 pt-6 mt-6">
                    <label class="block text-lg font-medium text-gray-700 mb-4">Choose Your Color</label>
                    <div id="room-color-picker" class="flex flex-wrap justify-center gap-3 max-w-md mx-auto">
                        <!-- Swatches will be injected here -->
                    </div>
                </div>

                <!-- Start Button -->
                <div class="border-t border-gray-200 pt-6 mt-6">
                    <button id="start-game-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-md shadow-lg text-xl transition duration-200">
                        Start Game
                    </button>
                    <p class="text-gray-600 text-sm mt-4">Don't forget to join the <b class="text-green-600">Voice Chat</b>! (Button is in the header)</p>
                    <p id="start-game-error" class="text-red-500 text-sm mt-2 h-4"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Container for hidden audio elements -->
    <div id="audio-streams" class="hidden"></div>

    <!-- Generic Message Modal -->
    <div id="message-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center">
            <p id="message-text" class="text-xl text-gray-800 mb-6">This is a message.</p>
            <button id="message-ok-button" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-6 rounded-md">
                OK
            </button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop">
        <div class="bg-white rounded-lg shadow-xl p-12 text-center">
            <h2 class="text-5xl font-bold text-yellow-500 mb-6">Game Over!</h2>
            <p class="text-3xl text-gray-800 mb-8">
                Winner: <span id="winner-name" class="font-bold text-cyan-600"></span>
            </p>
            <button id="play-again-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-md shadow-lg text-xl transition duration-200">
                Play Again
            </button>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc, 
            updateDoc, 
            onSnapshot, 
            arrayUnion, 
            serverTimestamp,
            setLogLevel
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Game Constants ---
        const GRID_SIZE = 6;
        const SHIP_COUNT = 5;
        const MINE_COUNT = 3; // NEW
        const MAX_PLAYERS = 20;

        // --- Global Variables ---
        let app, db, auth;
        let userId, myPlayerName, currentRoomCode;
        let localGameData = null;
        let unsubscribeRoom = null;
        let isSpectator = false;
        
        // --- NEW: WebRTC Voice Chat Globals (Firebase Signaling) ---
        let localStream = null;
        let isMuted = false;
        let inVoiceChat = false; // Tracks if I've *clicked* "Join Voice"
        let rtcConnections = {}; // { otherPlayerId: RTCPeerConnection }
        let audioElements = {};   // { otherPlayerId: HTMLAudioElement }
        
        // State for click-to-move
        let shipToMoveIndex = null;  // Index of the ship being moved
        let validMoveIndices = [];   // Array of valid destination indices
        let hasMovedShipThisTurn = false; // Local flag for ship movement

        // Darker Pastel colors
        const PLAYER_COLORS = [
            '#60A5FA', // blue-400
            '#FB923C', // orange-400
            '#4ADE80', // green-400
            '#A78BFA', // violet-400
            '#FACC15', // yellow-400
            '#2DD4BF', // teal-400
            '#C084FC', // purple-400
            '#84CC16', // lime-500
            '#F97316', // orange-500
            '#5EEAD4', // cyan-300
            '#EC4899', // pink-500
            '#67CDBB', // Custom
            '#7BC6CC', // Custom
            '#D19ED4', // Custom
            '#6EE7B7', // emerald-300
            '#FADB5F', // Custom yellow
            '#99DDE0'  // Custom
        ];
        const DEFAULT_COLOR = '#6b7280'; // Gray

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyBaNyxRMOTb7a-NYu7Y1J1Q4pSweC-qZUQ",
            authDomain: "battleship-royal.firebaseapp.com",
            projectId: "battleship-royal",
            storageBucket: "battleship-royal.firebasestorage.app",
            messagingSenderId: "246405120799",
            appId: "1:246405120799:web:1ac4da9d7c951dfa96262a"
        };
        
        // This is a unique ID for your app's data in the database.
        const appId = 'battleship-royale-local'; 

        // --- DOM Elements ---
        const loadingScreen = document.getElementById('loading-screen');
        const loginScreen = document.getElementById('login-screen');
        const gameScreen = document.getElementById('game-screen');
        
        const nameInput = document.getElementById('name-input');
        const roomInput = document.getElementById('room-input');
        const joinButton = document.getElementById('join-button');
        const createRoomButton = document.getElementById('create-room-button');
        const loginError = document.getElementById('login-error');

        const roomDisplay = document.getElementById('room-display');
        const gameStatus = document.getElementById('game-status');
        const myNameDisplay = document.getElementById('my-name-display');
        const voiceChatButton = document.getElementById('voice-chat-button');
        const muteSelfButton = document.getElementById('mute-self-button');
        
        const setupControls = document.getElementById('setup-controls');
        const setupInstructions = document.getElementById('setup-instructions');
        const shipsPlacedCount = document.getElementById('ships-placed-count');
        const minesPlacedCount = document.getElementById('mines-placed-count'); // NEW
        const readyButton = document.getElementById('ready-button');
        
        const myGridContainer = document.getElementById('my-grid-container');
        const opponentGridsContainer = document.getElementById('opponent-grids-container');
        const gameLogContainer = document.getElementById('game-log-container');

        const chatControls = document.getElementById('chat-controls');
        const chatInput = document.getElementById('chat-input');
        const chatSendButton = document.getElementById('chat-send-button');
        
        const waitingRoomControls = document.getElementById('waiting-room-controls');
        const playerListContainer = document.getElementById('player-list-container');
        const roomColorPicker = document.getElementById('room-color-picker'); 
        const startGameButton = document.getElementById('start-game-button');
        const startGameError = document.getElementById('start-game-error');
        
        const messageModal = document.getElementById('message-modal');
        const messageText = document.getElementById('message-text');
        const messageOkButton = document.getElementById('message-ok-button');
        
        const gameOverModal = document.getElementById('game-over-modal');
        const winnerName = document.getElementById('winner-name');
        const playAgainButton = document.getElementById('play-again-button');
        const audioStreamsContainer = document.getElementById('audio-streams');

        // --- Utility Functions ---

        /**
         * Shows a custom modal message.
         * @param {string} message - The message to display.
         */
        function showMessage(message) {
            messageText.textContent = message;
            messageModal.classList.remove('hidden');
        }

        /**
         * Generates a random, uppercase, alphanumeric room code.
         * @param {number} length - The desired length of the code.
         * @returns {string} - The generated room code.
         */
        function generateRoomCode(length) {
            const chars = 'ABCDEFGHIJKLMNPQRSTUVWXYZ123456789'; // Omitted O and 0 for clarity
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        /**
         * Gets the Firestore path for the current room.
         * @returns {string} - The document path.
         */
        function getRoomPath() {
            return `artifacts/${appId}/public/data/battleship_rooms/${currentRoomCode}`;
        }

        /**
         * Converts row and column to a 0-35 index.
         * @param {number} row - The row (0-5).
         * @param {number} col - The column (0-5).
         * @returns {number} - The grid index (0-35).
         */
        function toIndex(row, col) {
            return row * GRID_SIZE + col;
        }

        /**
         * Converts a grid index to row/col object.
         * @param {number} index - The grid index (0-35).
         * @returns {object} - { row, col }
         */
        function toRowCol(index) {
            return {
                row: Math.floor(index / GRID_SIZE),
                col: index % GRID_SIZE
            };
        }

        /**
         * Converts a grid index to "A1" style coordinates.
         * @param {number} index - The grid index (0-35).
         * @returns {string} - The coordinate string (e.g., "A1", "F6").
         */
        function toGridCoord(index) {
            const { row, col } = toRowCol(index);
            const rowLabel = ['A', 'B', 'C', 'D', 'E', 'F'][row];
            const colLabel = col + 1;
            return `${rowLabel}${colLabel}`;
        }

        /**
         * Creates a new player object.
         * @returns {object} - The player object.
         */
        function createNewPlayer() {
            return {
                userId: userId,
                name: myPlayerName,
                color: null, 
                grid: Array(GRID_SIZE * GRID_SIZE).fill(0),
                shipsPlaced: 0,
                minesPlaced: 0,
                shipsLeft: SHIP_COUNT, 
                isOut: false,
                ready: false,
                isSkippingTurn: false,
                // NEW: WebRTC Signaling fields
                inVoice: false,
                offers: [], // { from: otherUserId, offer: sdp }
                answers: [], // { from: otherUserId, answer: sdp }
                iceCandidates: [] // { from: otherUserId, candidate: candidate }
            };
        }

        /**
         * Creates the HTML for a single player's grid.
         * @param {object} player - The player data object.
         * @param {boolean} isMe - Is this grid for the current user?
         * @param {boolean} isTurnActive - Is it my turn and this is an opponent?
         * @returns {string} - The HTML string for the grid.
         */
        function createGridHTML(player, isMe, isTurnActive = false) {
            const gridClasses = isMe ? 'my-grid' : 'opponent-grid' + (isTurnActive ? ' turn-active' : '');
            let cellsHTML = '';
            const playerColor = player.color || DEFAULT_COLOR;
            
            // Add column headers
            cellsHTML += '<div class="grid-label"></div>'; // Empty corner
            for (let c = 1; c <= GRID_SIZE; c++) {
                cellsHTML += `<div class="grid-label">${c}</div>`;
            }

            // Add rows with headers
            const rowLabels = ['A', 'B', 'C', 'D', 'E', 'F']; 
            for (let r = 0; r < GRID_SIZE; r++) {
                cellsHTML += `<div class="grid-label">${rowLabels[r]}</div>`; // Row header
                for (let c = 0; c < GRID_SIZE; c++) {
                    const i = toIndex(r, c);
                    const cellState = player.grid[i];
                    let cellClass = 'grid-cell';
                    let content = '';
                    let style = '';

                    if (isMe) {
                        // My Grid: Show everything
                        if (cellState === 1) cellClass += ' ship';
                        if (cellState === 2) { 
                            cellClass += ' mine';
                            content = 'üí£';
                        }
                        
                        if (typeof cellState === 'object') {
                            if (cellState.type === 'miss') {
                                cellClass += ' miss';
                                content = 'X';
                                style = `color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'hit') {
                                cellClass += ' hit';
                                content = 'üö¢';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'mine-hit') {
                                cellClass += ' mine-hit';
                                content = 'üí•';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            }
                        }
                        // Show highlight if selected for moving
                        if (i === shipToMoveIndex) {
                            cellClass += ' ship-selected-for-move';
                        }
                        // Show highlight if it's a valid move option
                        if (validMoveIndices.includes(i)) {
                            cellClass += ' move-option';
                        }
                    } else {
                        // Opponent Grid: Show only hits and misses
                        if (typeof cellState === 'object') {
                             if (cellState.type === 'miss') {
                                cellClass += ' miss';
                                content = 'X';
                                style = `color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'hit') {
                                cellClass += ' hit';
                                content = 'üö¢';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'mine-hit') {
                                cellClass += ' mine-hit';
                                content = 'üí•';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            }
                        }
                    }
                    
                    cellsHTML += `<div class="${cellClass}" data-player-id="${player.userId}" data-row="${r}" data-col="${c}" style="${style}">${content}</div>`;
                }
            }

            return `
                <div class="p-2 sm:p-4 rounded-lg shadow-md ${gridClasses} ${isMe ? 'bg-blue-50' : 'bg-gray-50'}">
                    <h3 class="font-bold text-base sm:text-lg text-center mb-2" style="color: ${playerColor};">${player.name} ${player.inVoice ? 'üéôÔ∏è' : ''}</h3>
                    <p class="text-center text-xs sm:text-sm text-gray-600 mb-2 sm:mb-3">Ships Left: ${player.shipsLeft}</p>
                    ${player.isSkippingTurn ? '<p class="text-center text-xs sm:text-sm text-red-500 font-bold mb-2">SKIPPING TURN</p>' : ''}
                    <div class="grid-wrapper">
                        ${cellsHTML}
                    </div>
                </div>
            `;
        }

        /**
         * Creates an "Eliminated Player" card.
         * @param {object} player - The eliminated player object.
         * @returns {string} - The HTML string for the card.
         */
        function createPlayerOutHTML(player) {
            return `
                <div class="p-2 sm:p-4 rounded-lg shadow-md player-out-card">
                    <h3 class="font-bold text-base sm:text-lg text-center mb-3 text-gray-500">${player.name}</h3>
                    <p class="text-xl sm:text-2xl text-red-500 font-bold">ELIMINATED</p>
                </div>
            `;
        }

        /**
         * Renders the color picker in the waiting room.
         * @param {object} roomData - The current room data.
         */
        function renderColorPicker(roomData) {
            roomColorPicker.innerHTML = ''; // Clear existing swatches
            const usedColors = roomData.players.map(p => p.color).filter(Boolean);
            const myColor = roomData.players.find(p => p.userId === userId)?.color;

            PLAYER_COLORS.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.dataset.color = color;

                if (usedColors.includes(color) && color !== myColor) {
                    swatch.classList.add('disabled');
                }
                
                if (color === myColor) {
                    swatch.classList.add('selected');
                }
                
                roomColorPicker.appendChild(swatch);
            });
        }
        
        // --- Main UI Render Function ---

        /**
         * Renders the entire game UI based on the current game state.
         * @param {object} roomData - The data from Firestore.
         */
        function renderGameUI(roomData) {
            if (!roomData) return;
            
            const myPlayer = roomData.players.find(p => p.userId === userId);

            // NEW: Spectator check
            if (!myPlayer && !isSpectator) {
                // Kicked or data mismatch, return to login
                showMessage("An error occurred. Returning to login screen.");
                showLoginScreen();
                return;
            }
            
            // Update header
            roomDisplay.textContent = currentRoomCode;
            myNameDisplay.textContent = myPlayerName + (isSpectator ? " (Spectator)" : "");
            
            // Clear main containers
            myGridContainer.innerHTML = ''; // Will be re-filled
            opponentGridsContainer.innerHTML = '';
            gameLogContainer.innerHTML = '';
            playerListContainer.innerHTML = '';
            
            // Hide all conditional controls
            setupControls.classList.add('hidden');
            waitingRoomControls.classList.add('hidden');
            gameOverModal.classList.add('hidden');
            chatControls.classList.add('hidden'); // Hide chat by default
            
            // Render Game Log
            roomData.gameLog.slice().reverse().forEach(logEntry => {
                const p = document.createElement('p');
                if (logEntry.type === 'chat') {
                    p.className = 'log-chat-message';
                    // Sanitize message - very basic sanitation
                    const safeMessage = logEntry.message
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&#039;");
                    p.innerHTML = `<span class="font-bold" style="color: ${logEntry.color || DEFAULT_COLOR};">${logEntry.name}:</span> ${safeMessage}`;
                } else {
                    // Default to game event
                    p.className = 'log-game-event';
                    p.textContent = logEntry.message;
                }
                gameLogContainer.appendChild(p);
            });
            
            // --- NEW: Spectator UI ---
            if (isSpectator) {
                gameStatus.textContent = "Spectating Game in Progress";
                if (roomData.gameState === 'over') {
                    gameStatus.textContent = "Game Over!";
                }
                
                myGridContainer.innerHTML = `
                    <div class="p-4 h-full flex flex-col items-center justify-center text-center">
                        <h3 class="text-xl font-bold text-gray-700">Spectator Mode</h3>
                        <p class="text-gray-500 mt-2">You are watching this game. You do not have a grid.</p>
                    </div>
                `;

                // Render all player grids as opponents
                roomData.players.forEach(player => {
                    if (player.isOut) {
                        opponentGridsContainer.innerHTML += createPlayerOutHTML(player);
                    } else {
                        opponentGridsContainer.innerHTML += createGridHTML(player, false, false); // Never "my turn"
                    }
                });
                
                if (roomData.gameState === "over") {
                    const winner = roomData.players.find(p => p.userId === roomData.winner);
                    winnerName.textContent = winner ? winner.name : 'Unknown';
                    gameOverModal.classList.remove('hidden');
                }
                chatControls.classList.add('hidden'); // Spectators cannot chat
                return; // End render function for spectators
            }

            // --- Player UI (existing logic) ---
            switch (roomData.gameState) {
                case "waiting":
                    gameStatus.textContent = "Waiting for Players... (Share Code!)";
                    waitingRoomControls.classList.remove('hidden');
                    
                    roomData.players.forEach(player => {
                        const playerCard = `
                            <div class="p-4 bg-gray-100 rounded-lg shadow-md w-full max-w-xs text-center">
                                <h3 class="font-bold text-xl" style="color: ${player.color || DEFAULT_COLOR};">${player.name} ${player.inVoice ? 'üéôÔ∏è' : ''}</h3>
                                ${player.color ? '' : '<p class="text-sm text-red-500">Choosing color...</p>'}
                            </div>
                        `;
                        playerListContainer.innerHTML += playerCard;
                    });
                    
                    chatControls.classList.remove('hidden'); // Show chat for players
                    renderColorPicker(roomData);
                    break;

                case "setup":
                    setupControls.classList.remove('hidden');
                    shipsPlacedCount.textContent = myPlayer.shipsPlaced;
                    minesPlacedCount.textContent = myPlayer.minesPlaced; // NEW
                    
                    // NEW: Multi-stage setup instructions
                    if (myPlayer.shipsPlaced < SHIP_COUNT) {
                        gameStatus.textContent = "Place Your Ships!";
                        setupInstructions.textContent = `Place your ${SHIP_COUNT} ships. (Click on grid)`;
                    } else if (myPlayer.minesPlaced < MINE_COUNT) {
                        gameStatus.textContent = "Place Your Mines!";
                        setupInstructions.textContent = `Place your ${MINE_COUNT} mines. (Mines cannot be on ships)`;
                    } else if (!myPlayer.ready) {
                        gameStatus.textContent = "Ready Up!";
                        setupInstructions.textContent = `You are all set! Hit the Ready button.`;
                    } else {
                        gameStatus.textContent = "Waiting for others...";
                        setupInstructions.textContent = `Waiting for other players to get ready...`;
                    }
                    
                    readyButton.disabled = (myPlayer.shipsPlaced !== SHIP_COUNT) || (myPlayer.minesPlaced !== MINE_COUNT) || myPlayer.ready;
                    
                    chatControls.classList.remove('hidden'); // Show chat
                    myGridContainer.innerHTML = createGridHTML(myPlayer, true, false);
                    break;
                    
                case "playing":
                    const currentPlayer = roomData.players[roomData.currentPlayerIndex];
                    const isMyTurn = currentPlayer.userId === userId;
                    
                    if (isMyTurn) {
                        // NEW: Check for skipped turn
                        if (myPlayer.isSkippingTurn) {
                            gameStatus.textContent = "You hit a mine! Skipping your turn...";
                            gameStatus.classList.add('text-red-500');
                            // Skip turn immediately
                            setTimeout(handleSkipTurn, 2000); // 2s delay to show message
                        } else {
                            const oldPlayer = oldLocalGameData ? oldLocalGameData.players[oldLocalGameData.currentPlayerIndex] : null;
                            if (oldPlayer?.userId !== userId) {
                                hasMovedShipThisTurn = false;
                            }

                            opponentGridsContainer.style.pointerEvents = 'auto'; 

                            if (shipToMoveIndex !== null) {
                                calculateValidMoves(shipToMoveIndex, myPlayer.grid);
                                
                                if (myPlayer.grid[shipToMoveIndex] !== 1) {
                                    cancelMove(); 
                                    gameStatus.textContent = "Your Turn! Attack!";
                                    if (!hasMovedShipThisTurn) {
                                        gameStatus.textContent += " (Or click a ship to move)";
                                    }
                                    gameStatus.classList.add('text-yellow-500');
                                } else {
                                    gameStatus.textContent = "Move: Select an adjacent empty cell.";
                                    gameStatus.classList.add('text-yellow-500');
                                    opponentGridsContainer.style.pointerEvents = 'none'; 
                                }
                            } else {
                                gameStatus.textContent = "Your Turn! Attack!";
                                if (!hasMovedShipThisTurn) {
                                    gameStatus.textContent += " (Or click a ship to move)";
                                }
                                gameStatus.classList.add('text-yellow-500');
                            }
                        }
                    } else { 
                        gameStatus.textContent = `Waiting for ${currentPlayer.name}'s turn...`;
                        gameStatus.classList.remove('text-yellow-500', 'text-red-500');
                        hasMovedShipThisTurn = false; 
                        if (shipToMoveIndex !== null) cancelMove(); 
                    }
                    
                    chatControls.classList.remove('hidden'); // Show chat
                    myGridContainer.innerHTML = createGridHTML(myPlayer, true, false);

                    roomData.players.forEach(player => {
                        if (player.userId === userId) return; 
                        if (player.isOut) {
                            opponentGridsContainer.innerHTML += createPlayerOutHTML(player);
                        } else {
                            opponentGridsContainer.innerHTML += createGridHTML(player, false, isMyTurn && !myPlayer.isSkippingTurn && shipToMoveIndex === null);
                        }
                    });
                    break;
                    
                case "over":
                    const winner = roomData.players.find(p => p.userId === roomData.winner);
                    gameStatus.textContent = "Game Over!";
                    winnerName.textContent = winner ? winner.name : 'Unknown';
                    gameOverModal.classList.remove('hidden');
                    
                    chatControls.classList.remove('hidden'); // Show chat
                    myGridContainer.innerHTML = createGridHTML(myPlayer, true, false);
                    roomData.players.forEach(player => {
                         if (player.userId === userId) return;
                         opponentGridsContainer.innerHTML += createGridHTML(player, false, false);
                    });
                    break;
            }
        }
        
        // --- Event Handlers ---

        /**
         * Handles selecting a color in the waiting room.
         * @param {Event} e - The click event.
         */
        async function handleColorSelectInRoom(e) {
            const swatch = e.target.closest('.color-swatch');
            if (!swatch || swatch.classList.contains('disabled')) return;
            if (!localGameData || localGameData.gameState !== 'waiting') return;

            const newColor = swatch.dataset.color;
            const myPlayer = localGameData.players.find(p => p.userId === userId);

            if (myPlayer.color === newColor) return; 

            document.querySelectorAll('#room-color-picker .color-swatch').forEach(s => s.classList.remove('selected'));
            swatch.classList.add('selected');

            const newPlayers = localGameData.players.map(p => 
                p.userId === userId ? { ...p, color: newColor } : p
            );
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, { players: newPlayers });
            } catch (err) {
                console.error("Error setting color:", err);
                showMessage("Error setting color. Please try again.");
            }
        }


        async function handleCreateRoom() {
            const name = nameInput.value.trim();
            if (!name) {
                loginError.textContent = "Please enter your name.";
                return;
            }
            loginError.textContent = "";
            createRoomButton.disabled = true;
            createRoomButton.textContent = "Creating...";
            joinButton.disabled = true; 

            myPlayerName = name;
            let newRoomCode = '';
            let roomRef;
            let roomSnap;
            let attempts = 0;

            do {
                newRoomCode = generateRoomCode(5);
                currentRoomCode = newRoomCode; 
                roomRef = doc(db, getRoomPath());
                roomSnap = await getDoc(roomRef);
                attempts++;
                if (attempts > 10) { 
                    throw new Error("Failed to generate a unique room code.");
                }
            } while (roomSnap.exists());

            console.log(`Creating new room: ${newRoomCode}`);

            try {
                const newPlayer = createNewPlayer();
                const newRoomData = {
                    players: [newPlayer],
                    gameState: "waiting", 
                    currentPlayerIndex: 0,
                    gameLog: [{ type: 'game', message: `${myPlayerName} created the room.` }],
                    createdAt: serverTimestamp(),
                    winner: null
                };
                await setDoc(roomRef, newRoomData);
                isSpectator = false; // You are the creator, not a spectator
                showGameScreen();
                listenToRoom();

            } catch (err) {
                console.error("Error creating room:", err);
                loginError.textContent = err.message;
                createRoomButton.disabled = false;
                createRoomButton.textContent = "Create New Game";
                joinButton.disabled = false;
            }
        }

        async function handleJoinRoom() {
            const name = nameInput.value.trim();
            const roomCode = roomInput.value.trim().toUpperCase();

            if (!name) {
                loginError.textContent = "Please enter your name.";
                return;
            }
            if (roomCode.length !== 5) {
                loginError.textContent = "Room code must be 5 characters.";
                return;
            }
            
            loginError.textContent = "";
            joinButton.disabled = true;
            joinButton.textContent = "Joining...";
            createRoomButton.disabled = true; 

            myPlayerName = name;
            currentRoomCode = roomCode;
            
            const roomRef = doc(db, getRoomPath());
            
            try {
                const roomSnap = await getDoc(roomRef);
                
                if (!roomSnap.exists()) {
                    throw new Error("Room not found. Check the code.");
                } 
                
                const roomData = roomSnap.data();
                const isRejoining = roomData.players.find(p => p.userId === userId);

                if (isRejoining) {
                    // Player rejoining, just update name. Color is preserved.
                    const newPlayers = roomData.players.map(p => 
                        p.userId === userId ? { ...p, name: myPlayerName } : p
                    );
                    await updateDoc(roomRef, { players: newPlayers });
                    isSpectator = false;
                } else {
                    // New player joining
                    if (roomData.gameState === "waiting") {
                        if (roomData.players.length >= MAX_PLAYERS) { 
                            throw new Error(`Room is full (max ${MAX_PLAYERS} players).`);
                        }
                        const newPlayer = createNewPlayer();
                        await updateDoc(roomRef, {
                            players: arrayUnion(newPlayer),
                            gameLog: arrayUnion({ type: 'game', message: `${myPlayerName} joined the room.` })
                        });
                        isSpectator = false;
                    } else {
                        // Game in progress, join as spectator
                        isSpectator = true;
                        await updateDoc(roomRef, {
                             gameLog: arrayUnion({ type: 'game', message: `${myPlayerName} joined as a spectator.` })
                        });
                    }
                }
                
                showGameScreen();
                listenToRoom();
                
            } catch (err) {
                console.error("Error joining room:", err);
                loginError.textContent = err.message;
                joinButton.disabled = false;
                joinButton.textContent = "Join Game";
                createRoomButton.disabled = false;
            }
        }
        
        async function handleStartGame() {
            if (!localGameData) return;
            if (localGameData.players.length < 2) {
                startGameError.textContent = "Need at least 2 players to start.";
                return;
            }

            if (localGameData.players.some(p => p.color === null)) {
                 startGameError.textContent = "All players must choose a color before starting.";
                 return;
            }
            
            startGameError.textContent = "";
            startGameButton.disabled = true;
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    gameState: "setup",
                    gameLog: arrayUnion({ type: 'game', message: "The game is starting! Place your items." })
                });
            } catch (err) {
                console.error("Error starting game:", err);
                startGameError.textContent = "Error starting game. Please try again.";
                startGameButton.disabled = false;
            }
        }
        
        // --- NEW: WebRTC (Firebase Signaling) Functions ---

        /**
         * Creates a new RTCPeerConnection and configures it.
         * @param {string} otherUserId - The user ID of the player to connect to.
         */
        function createPeerConnection(otherUserId) {
            if (rtcConnections[otherUserId]) return rtcConnections[otherUserId];

            console.log(`Creating new RTCPeerConnection for ${otherUserId}`);
            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            rtcConnections[otherUserId] = pc;

            // Add local stream tracks
            if (localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            }

            // Handle incoming ICE candidates
            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    console.log(`Sending ICE candidate to ${otherUserId}`);
                    const me = localGameData.players.find(p => p.userId === userId);
                    // FIX: 'from' should be me, 'target' should be other
                    const myCandidates = [
                        ...me.iceCandidates, 
                        { from: userId, target: otherUserId, candidate: event.candidate.toJSON() }
                    ];
                    // Update only my player object's candidates
                    const newPlayers = localGameData.players.map(p => 
                        p.userId === userId ? { ...p, iceCandidates: myCandidates } : p
                    );
                    await updateDoc(doc(db, getRoomPath()), { players: newPlayers });
                }
            };

            // Handle incoming remote stream
            pc.ontrack = (event) => {
                console.log(`Receiving track from ${otherUserId}`);
                let audioEl = audioElements[otherUserId];
                if (!audioEl) {
                    audioEl = document.createElement('audio');
                    audioEl.autoplay = true;
                    audioElements[otherUserId] = audioEl;
                    audioStreamsContainer.appendChild(audioEl);
                }
                audioEl.srcObject = event.streams[0];
            };
            
            pc.onconnectionstatechange = () => {
                console.log(`Connection state for ${otherUserId}: ${pc.connectionState}`);
                if (pc.connectionState === 'failed' || pc.connectionState === 'closed' || pc.connectionState === 'disconnected') {
                    cleanupPeerConnection(otherUserId);
                }
            };

            return pc;
        }

        /**
         * Joins the voice chat by getting mic access and updating state.
         */
        async function handleJoinVoiceChat() {
            if (localStream || isSpectator) return; 
            voiceChatButton.disabled = true;
            voiceChatButton.textContent = "Joining...";

            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                inVoiceChat = true;

                voiceChatButton.textContent = "Voice Joined üéôÔ∏è";
                muteSelfButton.classList.remove('hidden');

                // Update our state in Firestore
                const newPlayers = localGameData.players.map(p => 
                    p.userId === userId ? { ...p, inVoice: true } : p
                );
                await updateDoc(doc(db, getRoomPath()), { players: newPlayers });

            } catch (err) {
                console.error("Error joining voice chat:", err);
                showMessage("Could not access microphone. Please check permissions.");
                cleanupAllVoice();
            }
        }

        /**
         * Toggles local microphone mute state.
         */
        function handleMuteSelf() {
            if (!localStream) return;
            isMuted = !isMuted;
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !isMuted;
            });
            muteSelfButton.textContent = isMuted ? "Unmute üéôÔ∏è" : "Mute Self üîá";
            muteSelfButton.classList.toggle('bg-yellow-500', !isMuted);
            muteSelfButton.classList.toggle('hover:bg-yellow-600', !isMuted);
            muteSelfButton.classList.toggle('bg-red-500', isMuted);
            muteSelfButton.classList.toggle('hover:bg-red-600', isMuted);
        }

        /**
         * Cleans up a single peer connection.
         * @param {string} otherUserId - The user ID to disconnect from.
         */
        function cleanupPeerConnection(otherUserId) {
            if (rtcConnections[otherUserId]) {
                rtcConnections[otherUserId].close();
                delete rtcConnections[otherUserId];
            }
            if (audioElements[otherUserId]) {
                audioElements[otherUserId].remove();
                delete audioElements[otherUserId];
            }
            console.log(`Cleaned up connection for ${otherUserId}`);
        }

        /**
         * Cleans up all voice chat state (on leave/logout).
         */
        async function cleanupAllVoice() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            inVoiceChat = false;
            
            if (localGameData && currentRoomCode) { // Check if room exists
                // Try to clear voice state in Firestore
                try {
                    const myPlayer = localGameData.players.find(p => p.userId === userId);
                    if (myPlayer && myPlayer.inVoice) {
                        const newPlayers = localGameData.players.map(p => 
                            p.userId === userId ? { ...p, inVoice: false, offers: [], answers: [], iceCandidates: [] } : p
                        );
                        await updateDoc(doc(db, getRoomPath()), { players: newPlayers });
                    }
                } catch (err) {
                    console.warn("Could not clear voice state on cleanup:", err);
                }
            }

            Object.keys(rtcConnections).forEach(cleanupPeerConnection);
            rtcConnections = {};
            audioElements = {};
            audioStreamsContainer.innerHTML = '';
            
            muteSelfButton.classList.add('hidden');
            voiceChatButton.classList.add('hidden');
            voiceChatButton.disabled = false;
            voiceChatButton.textContent = "Join Voice üéôÔ∏è";
            isMuted = false;
        }

        /**
         * Handles clicking on a grid cell (for setup, moving, or attacking).
         * @param {Event} e - The click event.
         */
        function handleGridClick(e) {
            const cellEl = e.target.closest('.grid-cell');
            if (!cellEl) return;
            if (!localGameData || isSpectator) return; // Spectators can't click grids
            
            const row = parseInt(cellEl.dataset.row);
            const col = parseInt(cellEl.dataset.col);
            if (isNaN(row) || isNaN(col)) return; 
            
            const index = toIndex(row, col);
            const currentPlayer = localGameData.players[localGameData.currentPlayerIndex];
            const isMyTurn = localGameData.gameState === 'playing' && currentPlayer.userId === userId;

            // --- Move Ship Logic ---
            if (isMyTurn && cellEl.closest('.my-grid') && !currentPlayer.isSkippingTurn) {
                const myPlayer = localGameData.players.find(p => p.userId === userId);

                if (validMoveIndices.includes(index)) {
                    executeSilentMove(shipToMoveIndex, index);
                    return; 
                }

                if (!hasMovedShipThisTurn && myPlayer.grid[index] === 1 && index !== shipToMoveIndex) { 
                    cancelMove(); 
                    shipToMoveIndex = index;
                    calculateValidMoves(index, myPlayer.grid);
                    renderGameUI(localGameData); 
                    return; 
                }
                
                if (shipToMoveIndex !== null) {
                    cancelMove();
                    renderGameUI(localGameData);
                    return;
                }
            }

            // --- Setup Logic ---
            if (localGameData.gameState === 'setup') {
                const myPlayer = localGameData.players.find(p => p.userId === userId);
                if (myPlayer.ready) return; 
                if (cellEl.closest('.my-grid')) {
                    handleSetupClick(index);
                }
            } 
            // --- Attack Logic ---
            else if (isMyTurn && cellEl.closest('.opponent-grid') && !currentPlayer.isSkippingTurn) {
                if (shipToMoveIndex === null) {
                    handleAttackClick(cellEl.dataset.playerId, index);
                } else {
                    cancelMove();
                    renderGameUI(localGameData);
                }
            }
        }

        /**
         * Handles placing/removing a ship during setup.
         * @param {number} index - The cell index clicked (0-35).
         */
        async function handleSetupClick(index) {
            // FIX: Optimistic UI Update
            if (!localGameData) return;
            const myPlayer = localGameData.players.find(p => p.userId === userId);
            if (!myPlayer || myPlayer.ready) return;

            let newGrid = [...myPlayer.grid];
            let newShipsPlaced = myPlayer.shipsPlaced;
            let newMinesPlaced = myPlayer.minesPlaced;
            
            const currentCell = newGrid[index];
            
            if (newShipsPlaced < SHIP_COUNT) {
                // Placing ships
                if (currentCell === 0) {
                    newGrid[index] = 1; // Place ship
                    newShipsPlaced++;
                } else if (currentCell === 1) {
                    newGrid[index] = 0; // Remove ship
                    newShipsPlaced--;
                }
            } else if (newMinesPlaced < MINE_COUNT) {
                // Placing mines
                if (currentCell === 0) {
                    newGrid[index] = 2; // Place mine
                    newMinesPlaced++;
                } else if (currentCell === 2) {
                    newGrid[index] = 0; // Remove mine
                    newMinesPlaced--;
                } else if (currentCell === 1) {
                    showMessage("Cannot place a mine on a ship!");
                }
            } else if (currentCell === 1) {
                // All items placed, can only remove ships
                newGrid[index] = 0;
                newShipsPlaced--;
            } else if (currentCell === 2) {
                 // All items placed, can only remove mines
                newGrid[index] = 0;
                newMinesPlaced--;
            } else {
                return; // Clicked on invalid spot
            }

            // Optimistically update local data and re-render
            const newPlayers = localGameData.players.map(p => 
                p.userId === userId ? { ...p, grid: newGrid, shipsPlaced: newShipsPlaced, minesPlaced: newMinesPlaced } : p
            );
            localGameData.players = newPlayers;
            renderGameUI(localGameData); // Re-render immediately
            
            // Update Firestore in the background
            const roomRef = doc(db, getRoomPath());
            try {
                // Note: We only update 'players', not the whole localGameData
                await updateDoc(roomRef, { players: newPlayers });
            } catch (err) {
                console.error("Error placing item:", err);
                showMessage("Error placing item. Please try again.");
                // TODO: Consider a rollback, but for setup it's low-risk
            }
        }

        /**
         * Handles the "Ready" button click.
         */
        async function handleReadyClick() {
            readyButton.disabled = true;
            
            const myPlayer = localGameData.players.find(p => p.userId === userId);
            if (myPlayer.shipsPlaced !== SHIP_COUNT || myPlayer.minesPlaced !== MINE_COUNT) { 
                 showMessage(`You must place all ${SHIP_COUNT} ships and ${MINE_COUNT} mines.`);
                 readyButton.disabled = false;
                 return;
            }

            const newPlayers = localGameData.players.map(p =>
                p.userId === userId ? { ...p, ready: true } : p
            );
            
            const allReady = newPlayers.every(p => p.ready);
            
            const roomRef = doc(db, getRoomPath());
            try {
                if (allReady) {
                    await updateDoc(roomRef, {
                        players: newPlayers,
                        gameState: "playing",
                        currentPlayerIndex: 0, 
                        gameLog: arrayUnion({ type: 'game', message: "All players are ready! The battle begins!" })
                    });
                } else {
                    await updateDoc(roomRef, { players: newPlayers });
                }
            } catch (err) {
                console.error("Error setting ready status:", err);
                showMessage("Error. Please try again.");
                readyButton.disabled = false;
            }
        }

        /**
         * Handles an attack on an opponent.
         * @param {string} targetPlayerId - The ID of the player being attacked.
         * @param {number} cellIndex - The cell index being attacked (0-35).
         */
        async function handleAttackClick(targetPlayerId, cellIndex) {
            cancelMove();
            opponentGridsContainer.style.pointerEvents = 'none';

            const attacker = localGameData.players[localGameData.currentPlayerIndex];
            const targetPlayer = localGameData.players.find(p => p.userId === targetPlayerId);
            
            if (typeof targetPlayer.grid[cellIndex] === 'object') {
                showMessage("That position has already been attacked!");
                opponentGridsContainer.style.pointerEvents = 'auto'; 
                return;
            }
            
            const targetCell = targetPlayer.grid[cellIndex];
            const wasHit = targetCell === 1;
            const wasMine = targetCell === 2; // NEW
            const coord = toGridCoord(cellIndex);
            
            let logMsg = { type: 'game', message: "" };
            let newLogMessages = [];
            
            let newPlayers = [...localGameData.players];
            let newGameState = localGameData.gameState;
            let newWinner = null;
            let nextPlayerIndex = localGameData.currentPlayerIndex;
            
            const attackerColor = attacker.color || DEFAULT_COLOR; 
            const newGrid = [...targetPlayer.grid];
            let newShipsLeft = targetPlayer.shipsLeft;
            let newIsOut = targetPlayer.isOut;

            if (wasHit) {
                logMsg.message = `${attacker.name} attacked ${targetPlayer.name} at ${coord}... HIT! üö¢`;
                newGrid[cellIndex] = { type: 'hit', attackerId: attacker.userId, attackerColor: attackerColor };
                newShipsLeft--;
                if (newShipsLeft === 0) {
                    newIsOut = true;
                    newLogMessages.push({ type: 'game', message: `${targetPlayer.name} has been eliminated!` });
                }
            } else if (wasMine) { // NEW: Mine logic
                logMsg.message = `${attacker.name} attacked ${targetPlayer.name} at ${coord}... IT'S A MINE! üí•`;
                newGrid[cellIndex] = { type: 'mine-hit', attackerId: attacker.userId, attackerColor: attackerColor };
                
                // Mark attacker to skip their next turn
                newPlayers = newPlayers.map(p => 
                    p.userId === attacker.userId ? { ...p, isSkippingTurn: true } : p
                );
                newLogMessages.push({ type: 'game', message: `${attacker.name} hit a mine and will skip their next turn!` });
            } else {
                // Was a miss
                logMsg.message = `${attacker.name} attacked ${targetPlayer.name} at ${coord}... MISS! X`;
                newGrid[cellIndex] = { type: 'miss', attackerId: attacker.userId, attackerColor: attackerColor };
            }
            
            newLogMessages.unshift(logMsg); // Add main log message to start
            
            // Update target player
            newPlayers = newPlayers.map(p => 
                p.userId === targetPlayerId ? { ...p, grid: newGrid, shipsLeft: newShipsLeft, isOut: newIsOut } : p
            );

            // 2. Check for game over
            const playersStillIn = newPlayers.filter(p => !p.isOut);
            if (playersStillIn.length === 1) {
                newGameState = "over";
                newWinner = playersStillIn[0].userId;
                newLogMessages.push({ type: 'game', message: `GAME OVER! ${playersStillIn[0].name} is the winner!` });
            } else if (playersStillIn.length === 0) {
                newGameState = "over";
                newLogMessages.push({ type: 'game', message: "GAME OVER! It's a draw!" });
            }
            
            // 3. Determine next turn
            // Turn only advances on a MISS or a MINE HIT
            if (newGameState === "playing" && !wasHit) {
                do {
                    nextPlayerIndex = (nextPlayerIndex + 1) % newPlayers.length;
                } while (newPlayers[nextPlayerIndex].isOut);
            }
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    players: newPlayers,
                    gameState: newGameState,
                    winner: newWinner,
                    currentPlayerIndex: nextPlayerIndex,
                    gameLog: arrayUnion(...newLogMessages) 
                });
            } catch (err) {
                console.error("Error during attack:", err);
                showMessage("Error processing attack. Please try again.");
            } 
        }

        /**
         * NEW: Handles the automatic turn skip after hitting a mine.
         */
        async function handleSkipTurn() {
            if (!localGameData) return;
            
            let newPlayers = localGameData.players.map(p => 
                p.userId === userId ? { ...p, isSkippingTurn: false } : p
            );
            
            // Find next player
            let nextPlayerIndex = localGameData.currentPlayerIndex;
            do {
                nextPlayerIndex = (nextPlayerIndex + 1) % newPlayers.length;
            } while (newPlayers[nextPlayerIndex].isOut);
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    players: newPlayers,
                    currentPlayerIndex: nextPlayerIndex,
                    gameLog: arrayUnion({ type: 'game', message: `${myPlayerName} skipped their turn.` })
                });
            } catch (err) {
                console.error("Error skipping turn:", err);
            }
        }


        /**
         * NEW: Handles sending a chat message.
         */
        async function handleSendChat() {
            const message = chatInput.value.trim();
            if (!message) return;
            if (!localGameData || isSpectator) return; // Spectators can't chat

            chatInput.disabled = true;
            chatSendButton.disabled = true;

            const myPlayer = localGameData.players.find(p => p.userId === userId);
            const myColor = myPlayer?.color || DEFAULT_COLOR;
            const myName = myPlayerName; 

            const chatObject = { 
                type: 'chat', 
                name: myName, 
                color: myColor, 
                message: message 
            };

            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, { 
                    gameLog: arrayUnion(chatObject) 
                });
                chatInput.value = ''; // Clear input on success
            } catch (err) {
                console.error("Error sending chat:", err);
                showMessage("Error sending message. Please try again.");
            } finally {
                chatInput.disabled = false;
                chatSendButton.disabled = false;
                chatInput.focus();
            }
        }
        
        // --- REVISED: Ship Moving Functions ---

        /**
         * Calculates valid adjacent move destinations.
         * @param {number} fromIndex - The grid index to move from.
         * @param {Array} grid - The player's grid.
         */
        function calculateValidMoves(fromIndex, grid) {
            validMoveIndices = [];
            const { row, col } = toRowCol(fromIndex);
            
            const potentialMoves = [
                { r: row - 1, c: col }, // Up
                { r: row + 1, c: col }, // Down
                { r: row, c: col - 1 }, // Left
                { r: row, c: col + 1 }  // Right
            ];

            for (const move of potentialMoves) {
                if (move.r >= 0 && move.r < GRID_SIZE && move.c >= 0 && move.c < GRID_SIZE) {
                    const toIndex = toIndex(move.r, move.c);
                    if (grid[toIndex] === 0) {
                        validMoveIndices.push(toIndex);
                    }
                }
            }
        }

        /**
         * Cancels the "Move Ship" state.
         */
        function cancelMove() {
            shipToMoveIndex = null;
            validMoveIndices = [];
        }

        /**
         * Executes a silent ship move. Does NOT cost a turn.
         * @param {number} fromIndex - The grid index to move from.
         * @param {number} toIndex - The grid index to move to.
         */
        async function executeSilentMove(fromIndex, toIndex) {
            gameStatus.textContent = "Moving ship...";
            myGridContainer.style.pointerEvents = 'none'; 

            const myPlayer = localGameData.players.find(p => p.userId === userId);
            let newGrid = [...myPlayer.grid];
            newGrid[fromIndex] = 0; 
            newGrid[toIndex] = 1;   

            let newPlayers = localGameData.players.map(p => 
                p.userId === userId ? { ...p, grid: newGrid } : p
            );
            
            const oldLocalData = localGameData; // Keep a copy in case of error
            localGameData.players = newPlayers;
            hasMovedShipThisTurn = true;
            cancelMove(); 
            renderGameUI(localGameData); // Re-render immediately
            myGridContainer.style.pointerEvents = 'auto'; // Re-enable

            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    players: newPlayers
                });
            } catch (err) {
                console.error("Error moving ship:", err);
                showMessage("Error moving ship. Reverting move.");
                localGameData = oldLocalData;
                hasMovedShipThisTurn = false;
                renderGameUI(localGameData);
            }
        }


        // --- Screen Management ---
        
        function showLoginScreen() {
            loadingScreen.classList.add('hidden');
            gameScreen.classList.add('hidden');
            loginScreen.classList.remove('hidden');
            
            if (unsubscribeRoom) {
                unsubscribeRoom();
                unsubscribeRoom = null;
            }
            
            if (localGameData) { // Check if we were in a game
                cleanupAllVoice(); // NEW: Clean up all WebRTC state
            }
            
            localGameData = null;
            currentRoomCode = null;
            isSpectator = false; // Reset spectator flag
            cancelMove(); 
            hasMovedShipThisTurn = false; 
            
            joinButton.disabled = false;
            joinButton.textContent = "Join Game";
            createRoomButton.disabled = false;
            createRoomButton.textContent = "Create New Game";
        }
        
        function showGameScreen() {
            loadingScreen.classList.add('hidden');
            loginScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            
            // Only show voice button if NOT a spectator
            if (!isSpectator) {
                voiceChatButton.classList.remove('hidden');
            } else {
                voiceChatButton.classList.add('hidden');
                muteSelfButton.classList.add('hidden');
            }
        }

        // --- Firebase Initialization ---

        async function signIn() {
            try {
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Firebase Sign-In Error:", error);
                loadingScreen.innerHTML = "<h1>Auth Error</h1><p>Could not sign in. Check console and Firebase settings.</p>";
            }
        }
        
        /**
         * Main room listener. Handles game state and WebRTC signaling.
         */
        function listenToRoom() {
            if (unsubscribeRoom) {
                unsubscribeRoom();
            }
            
            const roomRef = doc(db, getRoomPath());
            unsubscribeRoom = onSnapshot(roomRef, (doc) => {
                if (doc.exists()) {
                    const oldLocalGameData = localGameData;
                    localGameData = doc.data();
                    
                    // --- NEW: WebRTC Signaling Logic ---
                    if (inVoiceChat && !isSpectator) {
                        handleSignaling(oldLocalGameData, localGameData);
                    }
                    // --- End WebRTC ---
                    

                    // Don't reset move state if I am still the current player
                    if (!isSpectator) {
                        const oldPlayerIndex = oldLocalGameData ? oldLocalGameData.currentPlayerIndex : -1;
                        const newPlayerIndex = localGameData.currentPlayerIndex;
                        const myPlayerIndex = localGameData.players.findIndex(p => p.userId === userId);
                        
                        if (oldPlayerIndex === myPlayerIndex && newPlayerIndex !== myPlayerIndex) {
                            hasMovedShipThisTurn = false;
                            cancelMove(); 
                        }
                    }

                    opponentGridsContainer.style.pointerEvents = 'auto';
                    myGridContainer.style.pointerEvents = 'auto';
                    
                    renderGameUI(localGameData);

                    if (!isSpectator && localGameData.gameState === 'playing') {
                        const currentPlayer = localGameData.players[localGameData.currentPlayerIndex];
                        const isMyTurn = currentPlayer.userId === userId;
                        if (isMyTurn) {
                            if(currentPlayer.isSkippingTurn) {
                                opponentGridsContainer.style.pointerEvents = 'none';
                                myGridContainer.style.pointerEvents = 'none';
                            } else if (shipToMoveIndex !== null) {
                                opponentGridsContainer.style.pointerEvents = 'none';
                            }
                        }
                    }

                    if (oldLocalGameData?.gameState !== 'over' && localGameData.gameState === 'over') {
                        setTimeout(() => {
                            gameOverModal.classList.remove('hidden');
                        }, 1000);
                    }
                } else {
                    showMessage("The game room no longer exists.");
                    showLoginScreen();
                }
            }, (error) => {
                console.error("Firestore Snapshot Error:", error);
                showMessage("Lost connection to game room.");
                showLoginScreen();
            });
        }
        
        /**
         * NEW: Handles all WebRTC signaling logic based on state changes.
         * @param {object} oldData - The previous room data.
         * @param {object} newData - The new room data.
         */
        async function handleSignaling(oldData, newData) {
            const myPlayer = newData.players.find(p => p.userId === userId);
            if (!myPlayer || !myPlayer.inVoice) return; // I'm not in voice chat

            const otherPlayers = newData.players.filter(p => p.userId !== userId);
            
            // Create a *copy* of my player data to batch updates
            let myOffers = [...myPlayer.offers];
            let myAnswers = [...myPlayer.answers];
            let myCandidates = [...myPlayer.iceCandidates];
            let changesMadeToMe = false;
            
            // This object will hold updates for *other* players (to consume signals)
            let otherPlayerUpdates = {};

            for (const player of otherPlayers) {
                if (player.inVoice) {
                    // --- 1. Create Connection if needed ---
                    if (!rtcConnections[player.userId]) {
                        const pc = createPeerConnection(player.userId);
                        
                        // FIX: Politeness rule
                        // The player with the "smaller" ID makes the offer.
                        if (userId < player.userId) {
                            // I make the offer
                            if (!myOffers.some(o => o.from === userId && o.target === player.userId)) {
                                console.log(`Creating offer for ${player.userId}`);
                                const offer = await pc.createOffer();
                                await pc.setLocalDescription(offer);
                                myOffers.push({ from: userId, target: player.userId, offer: offer.toJSON() });
                                changesMadeToMe = true;
                            }
                        }
                    }
                    
                    const pc = rtcConnections[player.userId];
                    if (!pc) continue; // Still creating

                    // --- 2. Handle Offers ---
                    const theirOffer = player.offers.find(o => o.from === player.userId && o.target === userId);
                    if (theirOffer && !pc.remoteDescription) {
                        console.log(`Answering offer from ${player.userId}`);
                        await pc.setRemoteDescription(new RTCSessionDescription(theirOffer.offer));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        
                        myAnswers.push({ from: userId, target: player.userId, answer: answer.toJSON() });
                        changesMadeToMe = true;
                        
                        // Consume the offer
                        otherPlayerUpdates[player.userId] = {
                            ...otherPlayerUpdates[player.userId],
                            offers: player.offers.filter(o => !(o.from === player.userId && o.target === userId))
                        };
                    }
                    
                    // --- 3. Handle Answers ---
                    const theirAnswer = player.answers.find(a => a.from === player.userId && a.target === userId);
                    if (theirAnswer && pc.localDescription && !pc.remoteDescription) {
                        console.log(`Setting remote answer from ${player.userId}`);
                        await pc.setRemoteDescription(new RTCSessionDescription(theirAnswer.answer));
                        
                        // Consume the answer
                        otherPlayerUpdates[player.userId] = {
                            ...otherPlayerUpdates[player.userId],
                            answers: player.answers.filter(a => !(a.from === player.userId && a.target === userId))
                        };
                    }
                    
                    // --- 4. Handle ICE Candidates ---
                    const theirCandidates = player.iceCandidates.filter(c => c.from === player.userId && c.target === userId);
                    if (theirCandidates.length > 0) {
                        console.log(`Adding ${theirCandidates.length} new ICE candidates from ${player.userId}`);
                        for (const cand of theirCandidates) {
                            if (pc.remoteDescription) {
                                try {
                                    await pc.addIceCandidate(new RTCIceCandidate(cand.candidate));
                                } catch (err) {
                                    console.warn("Error adding ICE candidate:", err, cand);
                                }
                            }
                        }
                        // Consume the candidates
                        otherPlayerUpdates[player.userId] = {
                            ...otherPlayerUpdates[player.userId],
                            iceCandidates: player.iceCandidates.filter(c => !(c.from === player.userId && c.target === userId))
                        };
                    }

                } else {
                    // Player left voice
                    if (rtcConnections[player.userId]) {
                        cleanupPeerConnection(player.userId);
                    }
                }
            }
            
            // --- 5. Batch Update Firestore ---
            // We batch all updates into one `updateDoc` call for efficiency
            let finalPlayerList = newData.players.map(p => {
                if (p.userId === userId) {
                    // Update my signals
                    return { ...p, offers: myOffers, answers: myAnswers, iceCandidates: myCandidates };
                }
                if (otherPlayerUpdates[p.userId]) {
                    // Consume signals from other players
                    return { ...p, ...otherPlayerUpdates[p.userId] };
                }
                return p; // No change
            });

            // Only update if there are actual changes
            if (changesMadeToMe || Object.keys(otherPlayerUpdates).length > 0) {
                await updateDoc(doc(db, getRoomPath()), { players: finalPlayerList });
            }
        }
        
        window.onload = () => {
            if (!firebaseConfig.apiKey || !firebaseConfig.projectId) {
                 loadingScreen.innerHTML = "<h1>Error</h1><p>Firebase is not configured. Please paste your `firebaseConfig` object into the script.</p>";
                return;
            }
            
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug'); 

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated with userId:", userId);
                        showLoginScreen(); 
                    } else {
                        console.log("User is not authenticated. Attempting sign-in...");
                        signIn();
                    }
                });

                // --- Bind Event Listeners ---
                createRoomButton.addEventListener('click', handleCreateRoom);
                joinButton.addEventListener('click', handleJoinRoom);
                startGameButton.addEventListener('click', handleStartGame);
                voiceChatButton.addEventListener('click', handleJoinVoiceChat);
                muteSelfButton.addEventListener('click', handleMuteSelf);
                
                myGridContainer.addEventListener('click', handleGridClick);
                opponentGridsContainer.addEventListener('click', handleGridClick);
                
                readyButton.addEventListener('click', handleReadyClick);
                
                roomColorPicker.addEventListener('click', handleColorSelectInRoom); 
                
                chatSendButton.addEventListener('click', handleSendChat);
                chatInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') {
                        handleSendChat();
                    }
                });
                
                messageOkButton.addEventListener('click', () => {
                    messageModal.classList.add('hidden');
                });
                
                playAgainButton.addEventListener('click', () => {
                    // Clean up voice connections before reload
                    cleanupAllVoice();
                    window.location.reload();
                });

                roomInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') joinButton.click();
                });

            } catch (err) {
                console.error("Firebase Init Error:", err);
                loadingScreen.innerHTML = "<h1>Error</h1><p>Could not initialize the application.</p>";
            }
        };

    </script>
</body>
</html>


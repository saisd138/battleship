<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battleship Royale</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load PeerJS Library -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        /* Custom game-specific styles */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Constants for grid size - MOBILE FIRST */
        :root {
            --grid-size: 6;
            --cell-size: 20px; /* Mobile size */
            --label-size: 20px; /* Mobile size */
        }
        
        /* Desktop grid sizes */
        @media (min-width: 640px) {
            :root {
                --cell-size: 35px; /* Desktop size */
                --label-size: 5px; /* Desktop size */
            }
        }

        /* Base cell style */
        .grid-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: #cce7ff; /* light-blue-100 */
            border: 1px solid #a3d5ff; /* light-blue-200 */
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; /* Mobile font size */
            font-weight: bold;
            transition: all 0.15s ease-in-out;
            position: relative;
        }
        @media (min-width: 640px) {
            .grid-cell {
                font-size: 1rem; /* Desktop font size */
            }
        }


        /* Row/Col labels */
        .grid-label {
            width: var(--label-size);
            height: var(--label-size);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.625rem; /* Mobile font size */
            font-weight: 600;
            color: #6b7280; /* gray-500 */
        }
        @media (min-width: 640px) {
            .grid-label {
                font-size: 0.75rem; /* Desktop font size */
            }
        }

        .grid-wrapper {
            display: grid;
            /* 1 label + 6 cells */
            grid-template-columns: var(--label-size) repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: var(--label-size) repeat(var(--grid-size), var(--cell-size));
            gap: 2px;
        }

        /* My grid: hover effect */
        .my-grid .grid-cell:not(.ship):not(.miss):not(.hit):not(.ship-selected-for-move):not(.move-option):not(.mine):hover {
            background-color: #a3d5ff; /* light-blue-200 */
        }
        
        /* My grid: placed ship */
        .my-grid .grid-cell.ship {
            background-color: #4b5563; /* gray-600 */
            border-color: #374151; /* gray-700 */
        }
        
        /* My grid: placed mine */
        .my-grid .grid-cell.mine {
            background-color: #cce7ff; /* light-blue-100 */
            border-color: #a3d5ff;
            color: #f97316; /* orange-500 */
        }

        /* Opponent grid: fog of war (looks default) */
        .opponent-grid .grid-cell.ship,
        .opponent-grid .grid-cell.mine {
            background-color: #cce7ff; /* light-blue-100 */
            cursor: not-allowed;
        }

        /* Opponent grid: active turn hover effect */
        .opponent-grid.turn-active .grid-cell:not(.miss):not(.hit):not(.mine-hit):hover {
            background-color: #fef08a; /* yellow-200 */
            border-color: #fde047; /* yellow-300 */
        }
        
        /* All grids: miss */
        .grid-cell.miss {
            cursor: not-allowed;
            /* Color is set by JS */
        }
        
        /* All grids: hit */
        .grid-cell.hit {
            /* Background-color is set by JS */
            border-color: #4b5563; /* gray-600 */
            cursor: not-allowed;
            animation: hit-animation 0.5s ease;
            color: #1f2937; /* gray-800 */
        }
        
        /* All grids: mine hit */
        .grid-cell.mine-hit {
            /* Background-color is set by JS */
            border-color: #ef4444; /* red-500 */
            cursor: not-allowed;
            animation: hit-animation 0.5s ease;
            color: #7f1d1d; /* red-900 */
        }
        
        @keyframes hit-animation {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* Style for ship selected to be moved */
        .grid-cell.ship-selected-for-move {
            background-color: #fef08a; /* yellow-200 */
            border-color: #fde047; /* yellow-300 */
            box-shadow: 0 0 10px #fde047;
        }

        /* Style for valid move options */
        .grid-cell.move-option {
            background-color: #cce7ff;
            border: 2px dashed #facc15; /* yellow-400 */
            cursor: pointer;
        }
        .grid-cell.move-option:hover {
            background-color: #fef9c3; /* yellow-100 */
        }

        /* NEW: Style for the last targeted cell */
        .grid-cell.last-target {
             outline: 3px solid #ef4444; /* red-500 */
             outline-offset: 1px;
             box-shadow: 0 0 8px rgba(239, 68, 68, 0.7); /* Optional: add a glow */
        }


        /* Player card when out */
        .player-out-card {
            background-color: #f3f4f6; /* gray-100 */
            border: 2px dashed #fca5a5; /* red-300 */
            color: #9ca3af; /* gray-400 */
            
            /* Sizing for Mobile (20*7 + 2*6 + 16*2) = 140+12+32 = 184px */
            width: 173px; 
            height: 221px; /* (20*7 + 2*6 + 16*2 + 18+20) ~ 221 */

            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }
        
        /* Sizing for Desktop */
        @media (min-width: 640px) {
            .player-out-card {
                width: 289px; /* (35*7 + 2*6 + 16*2) = 245+12+32 = 289 */
                height: 385px;
                padding: 16px;
            }
        }


        /* Modal backdrop */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.25);
        }

        /* Color picker */
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.15s ease;
        }
        .color-swatch.selected {
            border-color: #2563eb; /* blue-600 */
            box-shadow: 0 0 0 3px #fff;
        }
        .color-swatch:hover:not(.disabled) {
            opacity: 0.8;
        }
        .color-swatch.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            position: relative;
        }
        /* "X" mark for disabled colors */
        .color-swatch.disabled::before,
        .color-swatch.disabled::after {
            position: absolute;
            content: '';
            width: 70%;
            height: 2px;
            background-color: #4b5563;
            top: 50%;
            left: 15%;
            transform: rotate(45deg);
        }
        .color-swatch.disabled::after {
            transform: rotate(-45deg);
        }

        /* Game event log messages */
        .log-game-event {
            color: #DC2626; /* red-600 */
            font-style: italic;
            font-size: 0.875rem; /* text-sm */
        }
        
        /* Chat messages */
        .log-chat-message {
            font-size: 0.875rem; /* text-sm */
            word-break: break-word; /* Ensure long messages wrap */
        }


    </style>
</head>
<body class="bg-gray-50 text-gray-900 min-h-screen p-4 sm:p-6">

    <!-- Main Game Container -->
    <div id="app-container" class="max-w-screen-2xl mx-auto">

        <!-- Loading Screen -->
        <div id="loading-screen" class="text-center p-12">
            <h1 class="text-3xl font-bold text-cyan-600">Battleship Royale</h1>
            <p class="text-xl mt-4">Initializing connection...</p>
        </div>

        <!-- Login Screen -->
        <div id="login-screen" class="hidden max-w-lg mx-auto bg-white p-8 rounded-lg shadow-xl">
            <h1 class="text-3xl font-bold text-center text-cyan-600 mb-6">Battleship Royale</h1>
            
            <div class="space-y-4">
                <!-- Shared Name Input -->
                <div>
                    <label for="name-input" class="block text-sm font-medium text-gray-700 mb-1">Your Name</label>
                    <input type="text" id="name-input" class="w-full bg-white border border-gray-300 rounded-md p-3 text-gray-900 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="E.g., Captain-A">
                </div>

                <!-- Create Room -->
                <div class="border-b border-gray-200 pb-6">
                    <button id="create-room-button" class="w-full bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-3 px-4 rounded-md shadow-lg transition duration-200 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-opacity-50">
                        Create New Game
                    </button>
                </div>

                <!-- Join Room -->
                <div class="pt-4 space-y-4">
                    <p class="text-center text-gray-500 text-sm">...or join an existing game:</p>
                    <div>
                        <label for="room-input" class="block text-sm font-medium text-gray-700 mb-1">5-Character Room Code</label>
                        <input type="text" id="room-input" class="w-full bg-white border border-gray-300 rounded-md p-3 text-gray-900 font-mono uppercase focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="XYZ12" maxlength="5">
                    </div>
                    <button id="join-button" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-md shadow-lg transition duration-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                        Join Game
                    </button>
                </div>
                
                <p id="login-error" class="text-red-500 text-center text-sm h-4"></p>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="hidden">
            <!-- Header -->
            <div class="bg-white p-4 rounded-lg shadow-lg mb-6 flex flex-col sm:flex-row justify-between items-center space-y-2 sm:space-y-0">
                <div class="flex items-center gap-2">
                    <span class="text-sm text-gray-500">Room:</span>
                    <span id="room-display" class="text-xl font-bold font-mono text-yellow-500"></span>
                    <span id="host-indicator" class="text-xs font-bold text-gray-500 bg-gray-200 px-2 py-0.5 rounded-full hidden">(HOST)</span>
                </div>
                <!-- Voice Chat Buttons -->
                <div class="flex gap-2">
                    <button id="voice-chat-button" class="hidden bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md shadow-lg transition duration-200 text-sm">
                        Join Voice üéôÔ∏è
                    </button>
                    <button id="mute-self-button" class="hidden bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-md shadow-lg transition duration-200 text-sm">
                        Mute Self üîá
                    </button>
                </div>
                <h2 id="game-status" class="text-2xl font-bold text-center text-cyan-600">Waiting for players...</h2>
                <div>
                    <span class="text-sm text-gray-500">Player:</span>
                    <span id="my-name-display" class="text-xl font-bold text-gray-900"></span>
                </div>
            </div>

            <!-- Main Game Layout -->
            <div class="flex flex-col lg:flex-row gap-6">

                <!-- Left Column (My Grid + Setup) -->
                <div class="flex flex-col items-center lg:items-start flex-shrink-0 w-full lg:w-auto">
                    <!-- Setup Controls -->
                    <div id="setup-controls" class="hidden bg-white p-4 rounded-lg shadow-lg mb-6 text-center">
                        <h3 id="setup-instructions" class="text-xl font-semibold text-yellow-600">Place your 5 ships.</h3>
                        <p class="text-lg mt-2">
                            Ships: <span id="ships-placed-count" class="font-bold text-2xl">0</span> / 5
                            |
                            Mines: <span id="mines-placed-count" class="font-bold text-2xl">0</span> / 3
                        </p>
                        <button id="ready-button" disabled class="mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-md shadow-lg transition duration-200 disabled:bg-gray-400 disabled:cursor-not-allowed">
                            Ready
                        </button>
                    </div>

                    <!-- My Grid Container -->
                    <div id="my-grid-container" class="bg-white p-2 sm:p-4 rounded-lg shadow-lg">
                        <!-- My grid will be inserted here -->
                    </div>
                </div>

                <!-- Right Column (Opponent Grids) -->
                <div class="flex-grow min-w-0">
                    <div class="bg-white p-2 sm:p-4 rounded-lg shadow-lg h-full">
                        <h3 class="text-xl sm:text-2xl font-bold text-gray-800 mb-4 text-center sm:text-left">Opponents</h3>
                        <!-- Opponent Grids Area -->
                        <div id="opponent-grids-container" class="grid grid-cols-2 gap-2 sm:flex sm:flex-wrap sm:justify-center sm:gap-4 lg:justify-start overflow-y-auto p-1 sm:p-2 bg-gray-50 rounded-md" style="max-height: calc(100vh - 300px);">
                            <!-- Opponent grids will be inserted here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Game Log (MOVED) -->
            <div class="mt-6">
                <h3 class="text-xl font-semibold mb-2 text-gray-700">Game Log / Chat</h3>
                <div id="game-log-container" class="h-48 bg-gray-100 rounded-lg p-4 overflow-y-auto shadow-inner space-y-2">
                    <!-- Log messages will be inserted here -->
                </div>
                <!-- Chat Input -->
                <div id="chat-controls" class="mt-2 hidden">
                    <div class="flex gap-2">
                        <input type="text" id="chat-input" class="flex-grow bg-white border border-gray-300 rounded-md p-2 text-sm text-gray-900 focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="Type a message...">
                        <button id="chat-send-button" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded-md shadow-lg transition duration-200">
                            Send
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Start Game Button (for waiting room) -->
            <div id="waiting-room-controls" class="bg-white p-6 rounded-lg shadow-lg text-center mt-6">
                <h3 class="text-2xl font-bold text-gray-800 mb-4">Waiting Room</h3>
                
                <!-- Player List -->
                <div id="player-list-container" class="flex flex-wrap justify-center gap-4 mb-6">
                    <!-- Player list will be inserted here -->
                </div>
                
                <!-- Color Picker ADDED here -->
                <div class="border-t border-gray-200 pt-6 mt-6">
                    <label class="block text-lg font-medium text-gray-700 mb-4">Choose Your Color</label>
                    <div id="room-color-picker" class="flex flex-wrap justify-center gap-3 max-w-md mx-auto">
                        <!-- Swatches will be injected here -->
                    </div>
                </div>

                <!-- Start Button -->
                <div id="start-game-controls-container" class="border-t border-gray-200 pt-6 mt-6">
                    <button id="start-game-button" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-md shadow-lg text-xl transition duration-200">
                        Start Game
                    </button>
                    <p class="text-gray-600 text-sm mt-4">Don't forget to join the <b class="text-green-600">Voice Chat</b>! (Button is in the header)</p>
                    <p id="start-game-error" class="text-red-500 text-sm mt-2 h-4"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Container for hidden audio elements -->
    <div id="audio-streams" class="hidden"></div>

    <!-- Generic Message Modal -->
    <div id="message-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop">
        <div class="bg-white rounded-lg shadow-xl p-8 max-w-sm w-full text-center">
            <p id="message-text" class="text-xl text-gray-800 mb-6">This is a message.</p>
            <button id="message-ok-button" class="bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-6 rounded-md">
                OK
            </button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop">
        <div class="bg-white rounded-lg shadow-xl p-12 text-center">
            <h2 class="text-5xl font-bold text-yellow-500 mb-6">Game Over!</h2>
            <p class="text-3xl text-gray-800 mb-8">
                Winner: <span id="winner-name" class="font-bold text-cyan-600"></span>
            </p>
            <button id="play-again-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-md shadow-lg text-xl transition duration-200">
                Play Again
            </button>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged,
            signInWithCustomToken // Import this
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            setDoc, 
            updateDoc, 
            onSnapshot, 
            arrayUnion, 
            serverTimestamp,
            setLogLevel
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Game Constants ---
        const GRID_SIZE = 6;
        const SHIP_COUNT = 5;
        const MINE_COUNT = 3; 
        const MAX_PLAYERS = 20;

        // --- Global Variables ---
        let app, db, auth;
        let userId, myPlayerName, currentRoomCode;
        let localGameData = null;
        let unsubscribeRoom = null;
        let isSpectator = false;
        let isHost = false; // NEW: Track if current user is the host
        
        // --- PeerJS Voice Chat Globals ---
        let peer = null;
        let localStream = null;
        let voiceConnections = {}; // { otherPlayerId: Peer.MediaConnection }
        let audioElements = {};   // { otherPlayerId: HTMLAudioElement }
        let isMuted = false;
        
        // State for click-to-move
        let shipToMoveIndex = null;   // Grid Index (0-35) of the ship being moved
        let validMoveIndices = [];    // Array of valid destination grid indices (0-35)
        let hasMovedShipThisTurn = false; // Local flag for ship movement

        // Darker Pastel colors
        const PLAYER_COLORS = [
            '#60A5FA', // blue-400
            '#FB923C', // orange-400
            '#4ADE80', // green-400
            '#A78BFA', // violet-400
            '#FACC15', // yellow-400
            '#2DD4BF', // teal-400
            '#C084FC', // purple-400
            '#84CC16', // lime-500
            '#F97316', // orange-500
            '#5EEAD4', // cyan-300
            '#EC4899', // pink-500
            '#67CDBB', // Custom
            '#7BC6CC', // Custom
            '#D19ED4', // Custom
            '#6EE7B7', // emerald-300
            '#FADB5F', // Custom yellow
            '#99DDE0'  // Custom
        ];
        const DEFAULT_COLOR = '#6b7280'; // Gray

        // --- Firebase Configuration ---
        // Use provided config or fallback for local dev
        const firebaseConfig = typeof __firebase_config !== 'undefined'
            ? JSON.parse(__firebase_config)
            : {
                // FALLBACK CONFIG for local testing (replace with your own)
                apiKey: "AIzaSyBaNyxRMOTb7a-NYu7Y1J1Q4pSweC-qZUQ",
                authDomain: "battleship-royal.firebaseapp.com",
                projectId: "battleship-royal",
                storageBucket: "battleship-royal.firebasestorage.app",
                messagingSenderId: "246405120799",
                appId: "1:246405120799:web:1ac4da9d7c951dfa96262a"
            };

        // Use provided app ID or fallback
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'battleship-royale-local-dev'; 

        // --- DOM Elements ---
        const loadingScreen = document.getElementById('loading-screen');
        const loginScreen = document.getElementById('login-screen');
        const gameScreen = document.getElementById('game-screen');
        
        const nameInput = document.getElementById('name-input');
        const roomInput = document.getElementById('room-input');
        const joinButton = document.getElementById('join-button');
        const createRoomButton = document.getElementById('create-room-button');
        const loginError = document.getElementById('login-error');

        const roomDisplay = document.getElementById('room-display');
        const hostIndicator = document.getElementById('host-indicator'); // NEW
        const gameStatus = document.getElementById('game-status');
        const myNameDisplay = document.getElementById('my-name-display');
        const voiceChatButton = document.getElementById('voice-chat-button');
        const muteSelfButton = document.getElementById('mute-self-button');
        
        const setupControls = document.getElementById('setup-controls');
        const setupInstructions = document.getElementById('setup-instructions');
        const shipsPlacedCount = document.getElementById('ships-placed-count');
        const minesPlacedCount = document.getElementById('mines-placed-count'); 
        const readyButton = document.getElementById('ready-button');
        
        const myGridContainer = document.getElementById('my-grid-container');
        const opponentGridsContainer = document.getElementById('opponent-grids-container');
        const gameLogContainer = document.getElementById('game-log-container');

        const chatControls = document.getElementById('chat-controls');
        const chatInput = document.getElementById('chat-input');
        const chatSendButton = document.getElementById('chat-send-button');
        
        const waitingRoomControls = document.getElementById('waiting-room-controls');
        const playerListContainer = document.getElementById('player-list-container');
        const roomColorPicker = document.getElementById('room-color-picker'); 
        const startGameButton = document.getElementById('start-game-button');
        const startGameError = document.getElementById('start-game-error');
        const startGameControlsContainer = document.getElementById('start-game-controls-container');
        
        const messageModal = document.getElementById('message-modal');
        const messageText = document.getElementById('message-text');
        const messageOkButton = document.getElementById('message-ok-button');
        
        const gameOverModal = document.getElementById('game-over-modal');
        const winnerName = document.getElementById('winner-name');
        const playAgainButton = document.getElementById('play-again-button');
        const audioStreamsContainer = document.getElementById('audio-streams');

        // --- Utility Functions ---

        /**
         * Shows a custom modal message.
         * @param {string} message - The message to display.
         */
        function showMessage(message) {
            messageText.textContent = message;
            messageModal.classList.remove('hidden');
        }

        /**
         * Generates a random, uppercase, alphanumeric room code.
         * @param {number} length - The desired length of the code.
         * @returns {string} - The generated room code.
         */
        function generateRoomCode(length) {
            const chars = 'ABCDEFGHIJKLMNPQRSTUVWXYZ123456789'; // Omitted O and 0 for clarity
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        /**
         * Gets the Firestore path for the current room.
         * @returns {string} - The document path.
         */
        function getRoomPath() {
            // All data is stored in a single "public" collection for this app
            return `artifacts/${appId}/public/data/battleship_rooms/${currentRoomCode}`;
        }
        
        /**
         * Creates a unique PeerJS ID based on room and user.
         * This prevents collisions if the same user joins multiple rooms.
         * @param {string} roomId - The current room code.
         * @param {string} usrId - The current user ID.
         * @returns {string} - A unique ID for PeerJS.
         */
        function getPeerId(roomId, usrId) {
            // PeerJS IDs must be alphanumeric + dashes/underscores
            const safeUserId = usrId.replace(/[^a-zA-Z0-9-]/g, ''); // Allow dashes
            return `battleship-${roomId}-${safeUserId}`.slice(0, 100); // Keep ID reasonable
        }

        /**
         * Converts row and column to a 0-35 index.
         * @param {number} row - The row (0-5).
         * @param {number} col - The column (0-5).
         * @returns {number} - The grid index (0-35).
         */
        function toIndex(row, col) {
            return row * GRID_SIZE + col;
        }

        /**
         * Converts a grid index to row/col object.
         * @param {number} index - The grid index (0-35).
         * @returns {object} - { row, col }
         */
        function toRowCol(index) {
            return {
                row: Math.floor(index / GRID_SIZE),
                col: index % GRID_SIZE
            };
        }

        /**
         * Converts a grid index to "A1" style coordinates.
         * @param {number} index - The grid index (0-35).
         * @returns {string} - The coordinate string (e.g., "A1", "F6").
         */
        function toGridCoord(index) {
            if (index < 0 || index >= GRID_SIZE * GRID_SIZE) return null; // Add bounds check
            const { row, col } = toRowCol(index);
            const rowLabel = ['A', 'B', 'C', 'D', 'E', 'F'][row];
            const colLabel = col + 1;
            return `${rowLabel}${colLabel}`;
        }
       
        /**
         * Creates a new player object structure (used locally).
         * @returns {object} - The player object.
         */
        function createNewPlayerObject() {
            const grid = {};
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const coord = toGridCoord(toIndex(r,c));
                    if(coord) grid[coord] = 0; // 0 = empty
                }
            }

            return {
                // userId is the key in the players map
                name: myPlayerName,
                color: null, // Color set after joining
                grid: grid, 
                shipsPlaced: 0,
                minesPlaced: 0, 
                shipsLeft: SHIP_COUNT, 
                isOut: false,
                ready: false,
                peerId: null, // Will store their PeerJS ID
                isSkippingTurn: false // For mine penalty
            };
        }

        /**
         * Creates the HTML for a single player's grid.
         * @param {object} player - The player data object from the players map.
         * @param {string} playerId - The userId of the player this grid belongs to.
         * @param {boolean} isMe - Is this grid for the current user?
         * @param {boolean} isTurnActive - Is it my turn and this is an opponent?
         * @param {object} roomData - The current room data (needed for lastTarget highlight).
         * @returns {string} - The HTML string for the grid.
         */
        function createGridHTML(player, playerId, isMe, isTurnActive = false, roomData) {
            const gridClasses = isMe ? 'my-grid' : 'opponent-grid' + (isTurnActive ? ' turn-active' : '');
            let cellsHTML = '';
            const playerColor = player.color || DEFAULT_COLOR;
            
            // Add column headers
            cellsHTML += '<div class="grid-label"></div>'; // Empty corner
            for (let c = 1; c <= GRID_SIZE; c++) {
                cellsHTML += `<div class="grid-label">${c}</div>`;
            }

            // Add rows with headers
            const rowLabels = ['A', 'B', 'C', 'D', 'E', 'F']; 
            for (let r = 0; r < GRID_SIZE; r++) {
                cellsHTML += `<div class="grid-label">${rowLabels[r]}</div>`; // Row header
                for (let c = 0; c < GRID_SIZE; c++) {
                    const i = toIndex(r, c);
                    const coord = toGridCoord(i); 
                    if (!coord) continue; // Skip if coord generation failed

                    const cellState = player.grid[coord]; 
                    let cellClass = 'grid-cell';
                    let content = '';
                    let style = '';

                    if (isMe) {
                        // My Grid: Show everything
                        if (cellState === 1) cellClass += ' ship';
                        if (cellState === 2) { 
                            cellClass += ' mine';
                            content = 'üí£';
                        }
                        
                        if (typeof cellState === 'object') {
                            if (cellState.type === 'miss') {
                                cellClass += ' miss';
                                content = 'X';
                                style = `color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'hit') {
                                cellClass += ' hit';
                                content = 'üö¢';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'mine-hit') { 
                                cellClass += ' mine-hit';
                                content = 'üí•';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            }
                        }
                        // Show highlight if selected for moving
                        if (i === shipToMoveIndex) {
                            cellClass += ' ship-selected-for-move';
                        }
                        // Show highlight if it's a valid move option
                        if (validMoveIndices.includes(i)) {
                            cellClass += ' move-option';
                        }
                    } else {
                        // Opponent Grid: Show only hits and misses
                        if (typeof cellState === 'object') {
                             if (cellState.type === 'miss') {
                                cellClass += ' miss';
                                content = 'X';
                                style = `color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'hit') {
                                cellClass += ' hit';
                                content = 'üö¢';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            } else if (cellState.type === 'mine-hit') { 
                                cellClass += ' mine-hit';
                                content = 'üí•';
                                style = `background-color: ${cellState.attackerColor || DEFAULT_COLOR};`;
                            }
                        }
                    }

                    // NEW: Global highlight for last target
                    if (roomData && coord === roomData.lastTargetCoord && playerId === roomData.lastTargetPlayerId) {
                         cellClass += ' last-target';
                    }
                    
                    // data-player-id is the ID of the grid's owner
                    cellsHTML += `<div class="${cellClass}" data-player-id="${playerId}" data-index="${i}" data-coord="${coord}" style="${style}">${content}</div>`;
                }
            }

            // Display "(HOST)" next to the name if this player is the current host
            const isCurrentHost = roomData && (roomData.currentHostId ? playerId === roomData.currentHostId : playerId === roomData.creatorId);
            const hostLabel = isCurrentHost ? ' <span class="text-xs font-bold text-gray-400">(Host)</span>' : '';

            return `
                <div class="p-2 sm:p-4 rounded-lg shadow-md ${gridClasses} ${isMe ? 'bg-blue-50' : 'bg-gray-50'}">
                    <h3 class="font-bold text-base sm:text-lg text-center mb-2" style="color: ${playerColor};">${player.name}${hostLabel} ${player.peerId ? 'üéôÔ∏è' : ''}</h3>
                    <p class="text-center text-xs sm:text-sm text-gray-600 mb-2 sm:mb-3">Ships Left: ${player.shipsLeft}</p>
                    ${player.isSkippingTurn ? '<p class="text-center text-xs sm:text-sm text-red-500 font-bold mb-2">SKIPPING TURN</p>' : ''}
                    <div class="grid-wrapper">
                        ${cellsHTML}
                    </div>
                </div>
            `;
        }


        /**
         * Creates an "Eliminated Player" card.
         * @param {object} player - The eliminated player object.
         * @returns {string} - The HTML string for the card.
         */
        function createPlayerOutHTML(player) {
             // Display "(HOST)" next to the name if this player *was* the current host
            const isCurrentHost = localGameData && (localGameData.currentHostId ? player.userId === localGameData.currentHostId : player.userId === localGameData.creatorId);
            const hostLabel = isCurrentHost ? ' <span class="text-xs font-bold text-gray-400">(Host)</span>' : '';

            return `
                <div class="p-2 sm:p-4 rounded-lg shadow-md player-out-card">
                    <h3 class="font-bold text-base sm:text-lg text-center mb-3 text-gray-500">${player.name}${hostLabel}</h3>
                    <p class="text-xl sm:text-2xl text-red-500 font-bold">ELIMINATED</p>
                </div>
            `;
        }

        /**
         * Renders the color picker in the waiting room.
         * @param {object} roomData - The current room data.
         */
        function renderColorPicker(roomData) {
            roomColorPicker.innerHTML = ''; // Clear existing swatches
            const players = Object.values(roomData.players || {}); // Get players from map
            const usedColors = players.map(p => p.color).filter(Boolean);
            const myColor = roomData.players[userId]?.color;

            PLAYER_COLORS.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.dataset.color = color;

                if (usedColors.includes(color) && color !== myColor) {
                    swatch.classList.add('disabled');
                }
                
                if (color === myColor) {
                    swatch.classList.add('selected');
                }
                
                roomColorPicker.appendChild(swatch);
            });
        }
        
        // --- Main UI Render Function ---

        /**
         * Renders the entire game UI based on the current game state.
         * @param {object} roomData - The data from Firestore.
         */
        function renderGameUI(roomData) {
            if (!roomData || !roomData.players) {
                 console.warn("Render cancelled: roomData or roomData.players is missing.");
                 return; // Exit if data structure is incomplete
            }
            
            // Check if current user is the host
            const currentHostId = roomData.currentHostId || roomData.creatorId;
            isHost = userId === currentHostId;
            hostIndicator.classList.toggle('hidden', !isHost); // Show/hide host indicator

            const myPlayer = roomData.players[userId]; // Get player data from map

            // Spectator check (joined mid-game)
            if (!myPlayer && !isSpectator) {
                console.warn("My player data not found, but not a spectator. Re-checking auth.");
                return;
            }

            const isEliminated = myPlayer && myPlayer.isOut;
            
            // Update header
            roomDisplay.textContent = currentRoomCode;
            let nameSuffix = "";
            if (isSpectator) nameSuffix = " (Spectator)";
            if (isEliminated) nameSuffix = " (Eliminated)";
            myNameDisplay.textContent = myPlayerName + nameSuffix;
            
            // Clear main containers
            myGridContainer.innerHTML = ''; 
            opponentGridsContainer.innerHTML = '';
            gameLogContainer.innerHTML = '';
            playerListContainer.innerHTML = '';
            
            // Hide all conditional controls
            setupControls.classList.add('hidden');
            waitingRoomControls.classList.add('hidden');
            gameOverModal.classList.add('hidden');
            chatControls.classList.add('hidden'); 
            
            // Render Game Log
            (roomData.gameLog || []).slice().reverse().forEach(logEntry => {
                const p = document.createElement('p');
                if (logEntry.type === 'chat') {
                    p.className = 'log-chat-message';
                    const safeMessage = (logEntry.message || "") // Ensure message exists
                        .replace(/&/g, "&amp;")
                        .replace(/</g, "&lt;")
                        .replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;")
                        .replace(/'/g, "&#039;");
                    p.innerHTML = `<span class="font-bold" style="color: ${logEntry.color || DEFAULT_COLOR};">${logEntry.name || 'Unknown'}:</span> ${safeMessage}`;
                } else {
                    p.className = 'log-game-event';
                    p.textContent = logEntry.message || 'Game event';
                }
                gameLogContainer.appendChild(p);
            });
            
            // Get player entries for iteration
            const playerEntries = Object.entries(roomData.players || {});

            // --- Spectator UI (Joined mid-game) ---
            if (isSpectator) {
                gameStatus.textContent = "Spectating Game in Progress";
                if (roomData.gameState === 'over') {
                    gameStatus.textContent = "Game Over!";
                }
                
                myGridContainer.innerHTML = `
                    <div class="p-4 h-full flex flex-col items-center justify-center text-center">
                        <h3 class="text-xl font-bold text-gray-700">Spectator Mode</h3>
                        <p class="text-gray-500 mt-2">You are watching this game. You do not have a grid.</p>
                    </div>
                `;

                // Render all player grids as opponents
                playerEntries.forEach(([playerId, player]) => {
                    if (player.isOut) {
                        opponentGridsContainer.innerHTML += createPlayerOutHTML(player);
                    } else {
                        opponentGridsContainer.innerHTML += createGridHTML(player, playerId, false, false, roomData); 
                    }
                });
                
                if (roomData.gameState === "over") {
                    const winner = roomData.players[roomData.winner]; // Get winner from map
                    winnerName.textContent = winner ? winner.name : 'Unknown';
                    gameOverModal.classList.remove('hidden');
                }
                chatControls.classList.add('hidden'); 
                return; 
            }

            // --- Player UI (Not a mid-game spectator) ---
             const myPlayerData = roomData.players[userId]; // Ensure we have the latest data
             if (!myPlayerData) {
                 console.error("Could not find my player data after check. Aborting render.");
                 return; // Should not happen if not spectator, but safety check
             }

            switch (roomData.gameState) {
                case "waiting":
                    gameStatus.textContent = "Waiting for Players... (Share Code!)";
                    waitingRoomControls.classList.remove('hidden');
                    
                    playerEntries.forEach(([playerId, player]) => {
                        const isCurrentHost = (roomData.currentHostId ? playerId === roomData.currentHostId : playerId === roomData.creatorId);
                        const hostLabel = isCurrentHost ? ' <span class="text-xs font-bold text-gray-400">(Host)</span>' : '';
                        const playerCard = `
                            <div class="p-4 bg-gray-100 rounded-lg shadow-md w-full max-w-xs text-center">
                                <h3 class="font-bold text-xl" style="color: ${player.color || DEFAULT_COLOR};">${player.name}${hostLabel} ${player.peerId ? 'üéôÔ∏è' : ''}</h3>
                                ${player.color ? '' : '<p class="text-sm text-red-500">Choosing color...</p>'}
                            </div>
                        `;
                        playerListContainer.innerHTML += playerCard;
                    });
                    
                    chatControls.classList.remove('hidden'); 
                    renderColorPicker(roomData);

                    // Host-only Start Button
                    if (isHost) { // Use the global isHost flag
                        startGameButton.classList.remove('hidden');
                        document.getElementById('start-game-host-wait-msg')?.remove();
                    } else {
                        startGameButton.classList.add('hidden');
                        if (!document.getElementById('start-game-host-wait-msg')) {
                            const waitMsg = document.createElement('p');
                            waitMsg.id = 'start-game-host-wait-msg';
                            waitMsg.className = 'text-gray-600 text-sm mt-4';
                            waitMsg.textContent = 'Waiting for the host to start the game...';
                            startGameControlsContainer.appendChild(waitMsg);
                        }
                    }
                    break;

                case "setup":
                    setupControls.classList.remove('hidden');
                    shipsPlacedCount.textContent = myPlayerData.shipsPlaced;
                    minesPlacedCount.textContent = myPlayerData.minesPlaced; 
                    
                    if (myPlayerData.shipsPlaced < SHIP_COUNT) {
                        gameStatus.textContent = "Place Your Ships!";
                        setupInstructions.textContent = `Place your ${SHIP_COUNT} ships. (Click on grid)`;
                    } else if (myPlayerData.minesPlaced < MINE_COUNT) {
                        gameStatus.textContent = "Place Your Mines!";
                        setupInstructions.textContent = `Place your ${MINE_COUNT} mines. (Mines cannot be on ships)`;
                    } else if (!myPlayerData.ready) {
                        gameStatus.textContent = "Ready Up!";
                        setupInstructions.textContent = `You are all set! Hit the Ready button.`;
                    } else {
                        gameStatus.textContent = "Waiting for others...";
                        setupInstructions.textContent = `Waiting for other players to get ready...`;
                    }
                    
                    readyButton.disabled = (myPlayerData.shipsPlaced !== SHIP_COUNT) || (myPlayerData.minesPlaced !== MINE_COUNT) || myPlayerData.ready;
                    
                    chatControls.classList.remove('hidden'); 
                    myGridContainer.innerHTML = createGridHTML(myPlayerData, userId, true, false, roomData);
                    break;
                    
                case "playing":
                     // Determine current player using index and player map keys
                    const playerIds = Object.keys(roomData.players);
                    const currentPlayerId = playerIds[roomData.currentPlayerIndex];
                    const currentPlayer = roomData.players[currentPlayerId];

                    if (!currentPlayer) {
                        console.error("Current player not found at index", roomData.currentPlayerIndex);
                        // Attempt recovery or show error
                        // For now, just prevent errors
                        gameStatus.textContent = "Error: Player not found";
                        break; 
                    }

                    const isMyTurn = currentPlayerId === userId;
                    
                    if (isEliminated) {
                        gameStatus.textContent = "You are eliminated. Spectating...";
                        gameStatus.classList.remove('text-yellow-500', 'text-red-500');
                        if (shipToMoveIndex !== null) cancelMove();
                    
                    } else if (isMyTurn) {
                        if (myPlayerData.isSkippingTurn) {
                            gameStatus.textContent = "You hit a mine! Skipping your turn...";
                            gameStatus.classList.add('text-red-500');
                            setTimeout(handleSkipTurn, 2000); 
                        } else {
                            // Check if turn just changed to me
                            const oldPlayerId = oldLocalGameData ? Object.keys(oldLocalGameData.players)[oldLocalGameData.currentPlayerIndex] : null;
                             if (oldPlayerId !== userId) {
                                hasMovedShipThisTurn = false; // Reset move flag when turn starts
                            }


                            opponentGridsContainer.style.pointerEvents = 'auto'; 

                            if (shipToMoveIndex !== null) {
                                // Validate if the ship still exists at the location (it might have been hit)
                                const shipCoord = toGridCoord(shipToMoveIndex);
                                if (!shipCoord || myPlayerData.grid[shipCoord] !== 1) {
                                    cancelMove(); // Ship is gone or invalid index, cancel move
                                    gameStatus.textContent = "Your Turn! Attack!";
                                    if (!hasMovedShipThisTurn) {
                                         gameStatus.textContent += " (Or click a ship to move)";
                                    }
                                     gameStatus.classList.add('text-yellow-500');

                                } else {
                                     calculateValidMoves(shipToMoveIndex, myPlayerData.grid);
                                     gameStatus.textContent = "Move: Select an adjacent empty cell.";
                                     gameStatus.classList.add('text-yellow-500');
                                     opponentGridsContainer.style.pointerEvents = 'none';
                                }
                            } else {
                                gameStatus.textContent = "Your Turn! Attack!";
                                if (!hasMovedShipThisTurn) {
                                    gameStatus.textContent += " (Or click a ship to move)";
                                }
                                gameStatus.classList.add('text-yellow-500');
                            }
                        }
                    } else { 
                        gameStatus.textContent = `Waiting for ${currentPlayer.name}'s turn...`;
                        gameStatus.classList.remove('text-yellow-500', 'text-red-500');
                        // hasMovedShipThisTurn is reset automatically when turn changes away from me (in listener)
                        if (shipToMoveIndex !== null) cancelMove(); 
                    }
                    
                    chatControls.classList.remove('hidden'); 
                    myGridContainer.innerHTML = createGridHTML(myPlayerData, userId, true, false, roomData);

                    playerEntries.forEach(([playerId, player]) => {
                        if (playerId === userId) return; 
                        if (player.isOut) {
                            opponentGridsContainer.innerHTML += createPlayerOutHTML(player);
                        } else {
                            opponentGridsContainer.innerHTML += createGridHTML(player, playerId, false, isMyTurn && !myPlayerData.isSkippingTurn && shipToMoveIndex === null && !isEliminated, roomData);
                        }
                    });
                    break;
                    
                case "over":
                    const winnerId = roomData.winner;
                    const winner = winnerId ? roomData.players[winnerId] : null;
                    gameStatus.textContent = "Game Over!";
                    winnerName.textContent = winner ? winner.name : 'Draw'; // Changed default to Draw
                    gameOverModal.classList.remove('hidden');
                    
                    chatControls.classList.remove('hidden'); 
                    myGridContainer.innerHTML = createGridHTML(myPlayerData, userId, true, false, roomData);
                     playerEntries.forEach(([playerId, player]) => {
                         if (playerId === userId) return;
                         // Show final state of opponent grids
                         opponentGridsContainer.innerHTML += createGridHTML(player, playerId, false, false, roomData); 
                    });
                    break;
            }
        }
        
        // --- Event Handlers ---

        /**
         * Handles selecting a color in the waiting room.
         * Uses dot notation for atomic update.
         * @param {Event} e - The click event.
         */
        async function handleColorSelectInRoom(e) {
            const swatch = e.target.closest('.color-swatch');
            if (!swatch || swatch.classList.contains('disabled')) return;
            if (!localGameData || localGameData.gameState !== 'waiting') return;

            const newColor = swatch.dataset.color;
            const myPlayer = localGameData.players[userId];
            if (!myPlayer || myPlayer.color === newColor) return;

            // Optimistically update UI
            const oldColor = myPlayer.color;
            myPlayer.color = newColor; // Mutate local state
            renderColorPicker(localGameData); // Re-render picker immediately

            const roomRef = doc(db, getRoomPath());
            try {
                // Use dot notation for atomic update of a single player's color
                await updateDoc(roomRef, {
                    [`players.${userId}.color`]: newColor
                });
            } catch (err) {
                console.error("Error setting color:", err);
                showMessage("Error setting color. Reverting.");
                myPlayer.color = oldColor; // Revert local state on error
                renderColorPicker(localGameData); // Re-render picker
            }
        }


        async function handleCreateRoom() {
            const name = nameInput.value.trim();
            if (!name) {
                loginError.textContent = "Please enter your name.";
                return;
            }
            loginError.textContent = "";
            createRoomButton.disabled = true;
            createRoomButton.textContent = "Creating...";
            joinButton.disabled = true; 

            myPlayerName = name;
            let newRoomCode = '';
            let roomRef;
            let roomSnap;
            let attempts = 0;

            do {
                newRoomCode = generateRoomCode(5);
                currentRoomCode = newRoomCode; 
                roomRef = doc(db, getRoomPath());
                roomSnap = await getDoc(roomRef);
                attempts++;
                if (attempts > 10) { 
                    throw new Error("Failed to generate a unique room code.");
                }
            } while (roomSnap.exists());

            console.log(`Creating new room: ${newRoomCode}`);

            try {
                const newPlayer = createNewPlayerObject(); // Create the player structure
                const newRoomData = {
                    players: { // Initialize players map
                       [userId]: newPlayer 
                    }, 
                    gameState: "waiting", 
                    currentPlayerIndex: 0, // Index still used for turn order over playerIds array
                    gameLog: [{ type: 'game', message: `${myPlayerName} created the room.` }],
                    createdAt: serverTimestamp(),
                    winner: null,
                    creatorId: userId, 
                    currentHostId: userId, // NEW: Initially creator is host
                    lastTargetCoord: null, // NEW: For highlight
                    lastTargetPlayerId: null // NEW: For highlight
                };
                await setDoc(roomRef, newRoomData);
                isSpectator = false; 
                isHost = true; // NEW: Creator is host
                showGameScreen();
                listenToRoom();

            } catch (err) {
                console.error("Error creating room:", err);
                loginError.textContent = err.message;
                createRoomButton.disabled = false;
                createRoomButton.textContent = "Create New Game";
                joinButton.disabled = false;
            }
        }

        async function handleJoinRoom() {
            const name = nameInput.value.trim();
            const roomCode = roomInput.value.trim().toUpperCase();

            if (!name) {
                loginError.textContent = "Please enter your name.";
                return;
            }
            if (roomCode.length !== 5) {
                loginError.textContent = "Room code must be 5 characters.";
                return;
            }
            
            loginError.textContent = "";
            joinButton.disabled = true;
            joinButton.textContent = "Joining...";
            createRoomButton.disabled = true; 

            myPlayerName = name;
            currentRoomCode = roomCode;
            
            const roomRef = doc(db, getRoomPath());
            
            try {
                const roomSnap = await getDoc(roomRef);
                
                if (!roomSnap.exists()) {
                    throw new Error("Room not found. Check the code.");
                } 
                
                const roomData = roomSnap.data();
                const isRejoining = roomData.players && roomData.players[userId]; // Check if player exists in map

                if (isRejoining) {
                    // Player rejoining, just update name. Color is preserved.
                     await updateDoc(roomRef, {
                        [`players.${userId}.name`]: myPlayerName // Update only name using dot notation
                    });
                    isSpectator = false;
                    isHost = userId === (roomData.currentHostId || roomData.creatorId); // Check if rejoining user is host
                } else {
                    // New player joining
                    const playerCount = Object.keys(roomData.players || {}).length;
                    if (roomData.gameState === "waiting") {
                        if (playerCount >= MAX_PLAYERS) { 
                            throw new Error(`Room is full (max ${MAX_PLAYERS} players).`);
                        }
                        const newPlayer = createNewPlayerObject();
                        await updateDoc(roomRef, {
                            [`players.${userId}`]: newPlayer, // Add new player using key
                            gameLog: arrayUnion({ type: 'game', message: `${myPlayerName} joined the room.` })
                        });
                        isSpectator = false;
                        isHost = false; // New joiner is not host
                    } else {
                        // Game in progress, join as spectator
                        isSpectator = true;
                        isHost = false;
                        await updateDoc(roomRef, {
                             gameLog: arrayUnion({ type: 'game', message: `${myPlayerName} joined as a spectator.` })
                        });
                    }
                }
                
                showGameScreen();
                listenToRoom();
                
            } catch (err) {
                console.error("Error joining room:", err);
                loginError.textContent = err.message;
                joinButton.disabled = false;
                joinButton.textContent = "Join Game";
                createRoomButton.disabled = false;
            }
        }
        
        async function handleStartGame() {
            if (!localGameData) return;

             // Only host can start
             const currentHostId = localGameData.currentHostId || localGameData.creatorId;
            if (userId !== currentHostId) {
                startGameError.textContent = "Only the host can start the game.";
                return;
            }

            const players = Object.values(localGameData.players || {});
            if (players.length < 2) {
                startGameError.textContent = "Need at least 2 players to start.";
                return;
            }

            if (players.some(p => p.color === null)) {
                 startGameError.textContent = "All players must choose a color before starting.";
                 return;
            }
            
            startGameError.textContent = "";
            startGameButton.disabled = true;
            
            const roomRef = doc(db, getRoomPath());
            try {
                // Ensure playerIds array is created/updated for turn order
                const playerIdsInOrder = Object.keys(localGameData.players); 
                await updateDoc(roomRef, {
                    gameState: "setup",
                    playerIds: playerIdsInOrder, // Store the order for turns
                    gameLog: arrayUnion({ type: 'game', message: "The game is starting! Place your items." })
                });
            } catch (err) {
                console.error("Error starting game:", err);
                startGameError.textContent = "Error starting game. Please try again.";
                startGameButton.disabled = false; // Re-enable on error
            }
        }
        
        
        /**
         * Handles joining the integrated voice chat using PeerJS.
         */
        async function handleJoinVoiceChat() {
            if (peer || localStream || isSpectator) return; // Already joined or is spectator

            voiceChatButton.disabled = true;
            voiceChatButton.textContent = "Joining...";

            try {
                // 1. Get user's microphone
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                
                // 2. Initialize PeerJS
                const myPeerId = getPeerId(currentRoomCode, userId);
                peer = new Peer(myPeerId); 

                peer.on('open', async (id) => {
                    console.log('My PeerJS ID is:', id);
                    
                    voiceChatButton.textContent = "Voice Joined üéôÔ∏è";
                    muteSelfButton.classList.remove('hidden');
                    
                    // 4. Update our state in Firestore using dot notation
                    const roomRef = doc(db, getRoomPath());
                    // Only update if player data actually exists
                    if (localGameData && localGameData.players && localGameData.players[userId]) {
                         await updateDoc(roomRef, {
                             [`players.${userId}.peerId`]: id
                         });
                    } else {
                        console.warn("Attempted to set peerId, but player data not found locally.");
                    }
                    
                    peer.on('call', (call) => {
                        console.log(`Incoming call from ${call.peer}`);
                        call.answer(localStream); 
                        handleNewVoiceConnection(call);
                    });
                    
                    // Call others already in voice
                    const otherPlayers = Object.values(localGameData.players || {});
                    const otherPlayersInVoice = otherPlayers.filter(p => p.userId !== userId && p.peerId); // Check map values
                    for (const player of otherPlayersInVoice) {
                        callPlayer(player.peerId);
                    }
                });
                
                peer.on('error', (err) => {
                    console.error("PeerJS Error:", err);
                    showMessage(`Voice Chat Error: ${err.message}. Please try rejoining.`);
                    cleanupAllVoice(); 
                });

            } catch (err) {
                console.error("Error joining voice chat:", err);
                showMessage("Could not access microphone. Please check permissions.");
                cleanupAllVoice();
            }
        }
        
        /**
         * Calls a specific PeerJS ID.
         */
        function callPlayer(peerId) {
             if (!peer || !localStream || !peerId) return; // Added check for peerId
             if (voiceConnections[peerId]) return; 
             
             console.log(`Calling ${peerId}`);
             try { // Add try-catch for potential peer.call errors
                 const call = peer.call(peerId, localStream);
                 if (call) { // Check if call was created
                    handleNewVoiceConnection(call);
                 } else {
                    console.warn(`Peer.call returned null for peerId: ${peerId}. Peer might not be available.`);
                 }
             } catch (err) {
                 console.error(`Error calling peer ${peerId}:`, err);
             }
        }
        
        /**
         * Manages a new voice connection (incoming or outgoing).
         */
        function handleNewVoiceConnection(call) {
             if (!call) return; // Safety check
            const peerId = call.peer;
            if (!peerId) return; // Safety check

            // Prevent duplicate handling if already connected
            if (voiceConnections[peerId]) {
                console.log(`Already have a connection with ${peerId}, ignoring new call object.`);
                return;
            }

            voiceConnections[peerId] = call;
            console.log(`Handling new voice connection with ${peerId}`);

            call.on('stream', (remoteStream) => {
                console.log(`Receiving stream from ${peerId}`);
                let audioEl = audioElements[peerId];
                if (!audioEl) {
                    audioEl = document.createElement('audio');
                    audioEl.autoplay = true; // Ensure autoplay is enabled
                     // Attempt to play explicitly after adding to DOM, helps with some browser policies
                    audioEl.onloadedmetadata = () => {
                         audioEl.play().catch(e => console.warn(`Audio play failed for ${peerId}:`, e));
                     };
                    audioElements[peerId] = audioEl;
                    audioStreamsContainer.appendChild(audioEl);
                }
                 if (audioEl.srcObject !== remoteStream) { // Avoid unnecessary srcObject assignments
                    audioEl.srcObject = remoteStream;
                }
            });

            call.on('close', () => {
                console.log(`Call with ${peerId} closed.`);
                cleanupPeerConnection(peerId);
            });
            
            call.on('error', (err) => {
                 console.error(`Call error with ${peerId}:`, err);
                 cleanupPeerConnection(peerId);
            });

            // Handle case where call might already be closed when event handlers are attached
            if (call.open === false) {
                 console.warn(`Call with ${peerId} was already closed.`);
                 cleanupPeerConnection(peerId);
            }
        }


        /**
         * Toggles local microphone mute state.
         */
        function handleMuteSelf() {
            if (!localStream) return;
            isMuted = !isMuted;
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !isMuted;
            });
            muteSelfButton.textContent = isMuted ? "Unmute üéôÔ∏è" : "Mute Self üîá";
            muteSelfButton.classList.toggle('bg-yellow-500', !isMuted);
            muteSelfButton.classList.toggle('hover:bg-yellow-600', !isMuted);
            muteSelfButton.classList.toggle('bg-red-500', isMuted);
            muteSelfButton.classList.toggle('hover:bg-red-600', isMuted);
        }

        /**
         * Handles clicking on a grid cell (for setup, moving, or attacking).
         */
        function handleGridClick(e) {
            const cellEl = e.target.closest('.grid-cell');
            if (!cellEl) return;
             if (!localGameData || isSpectator || !localGameData.players || !localGameData.players[userId]) {
                 return; // Exit if spectator or player data missing
             }
            
            const myPlayer = localGameData.players[userId];
            if (myPlayer.isOut) return; 
            
            const index = parseInt(cellEl.dataset.index); 
            if (isNaN(index)) return; 
            const coord = cellEl.dataset.coord; 
            if (!coord) return;
            
             // Determine current player using index and player map keys
             if (!localGameData.playerIds || localGameData.playerIds.length === 0) {
                 console.warn("Player order (playerIds) not set yet.");
                 return; // Cannot determine turn if order isn't set
             }
            const currentPlayerId = localGameData.playerIds[localGameData.currentPlayerIndex];
            const currentPlayer = localGameData.players[currentPlayerId];

            if (!currentPlayer) {
                console.error("Current player object not found for ID:", currentPlayerId);
                return;
            }

            const isMyTurn = currentPlayerId === userId;

            // --- Move Ship Logic ---
            if (isMyTurn && cellEl.closest('.my-grid') && !myPlayer.isSkippingTurn) { // Use myPlayer for skip check
                 if (validMoveIndices.includes(index)) {
                    executeSilentMove(shipToMoveIndex, index);
                    return; 
                }

                if (!hasMovedShipThisTurn && myPlayer.grid[coord] === 1 && index !== shipToMoveIndex) { 
                    cancelMove(); 
                    shipToMoveIndex = index; 
                    calculateValidMoves(index, myPlayer.grid); 
                    renderGameUI(localGameData); 
                    return; 
                }
                
                if (shipToMoveIndex !== null) {
                    cancelMove();
                    renderGameUI(localGameData);
                    return;
                }
            }

            // --- Setup Logic ---
            if (localGameData.gameState === 'setup') {
                if (myPlayer.ready) return; 
                if (cellEl.closest('.my-grid')) {
                    handleSetupClick(index, coord); 
                }
            } 
            // --- Attack Logic ---
            else if (isMyTurn && cellEl.closest('.opponent-grid') && !myPlayer.isSkippingTurn) { // Use myPlayer for skip check
                if (shipToMoveIndex === null) {
                    handleAttackClick(cellEl.dataset.playerId, index, coord); 
                } else {
                    cancelMove();
                    renderGameUI(localGameData);
                }
            }
        }

        /**
         * Handles placing/removing a ship or mine during setup.
         * Uses dot notation for atomic update.
         * @param {number} index - The cell index clicked (0-35).
         * @param {string} coord - The coordinate string (e.g., "A1").
         */
        async function handleSetupClick(index, coord) {
             const myPlayer = localGameData.players[userId];
             if (!myPlayer) return; // Should not happen

             let newGridValue = myPlayer.grid[coord];
             let newShipsPlaced = myPlayer.shipsPlaced;
             let newMinesPlaced = myPlayer.minesPlaced;

             const currentCell = myPlayer.grid[coord];

            if (newShipsPlaced < SHIP_COUNT) {
                if (currentCell === 0) { newGridValue = 1; newShipsPlaced++; }
                else if (currentCell === 1) { newGridValue = 0; newShipsPlaced--; }
                // Ignore clicks on mines during ship placement phase
            } else if (newMinesPlaced < MINE_COUNT) {
                if (currentCell === 0) { newGridValue = 2; newMinesPlaced++; }
                else if (currentCell === 2) { newGridValue = 0; newMinesPlaced--; }
                else if (currentCell === 1) { showMessage("Cannot place a mine on a ship!"); return; /* Do not proceed */ }
            } else { // All items placed, only allow removal
                if (currentCell === 1) { newGridValue = 0; newShipsPlaced--; }
                else if (currentCell === 2) { newGridValue = 0; newMinesPlaced--; }
            }

            // Check if anything actually changed
             if (newGridValue === currentCell) return;

            // Optimistic UI update
             const oldGridValue = currentCell;
             const oldShips = myPlayer.shipsPlaced;
             const oldMines = myPlayer.minesPlaced;
             myPlayer.grid[coord] = newGridValue;
             myPlayer.shipsPlaced = newShipsPlaced;
             myPlayer.minesPlaced = newMinesPlaced;
             renderGameUI(localGameData); // Update immediately

            // Update Firestore using dot notation
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    [`players.${userId}.grid.${coord}`]: newGridValue,
                    [`players.${userId}.shipsPlaced`]: newShipsPlaced,
                    [`players.${userId}.minesPlaced`]: newMinesPlaced
                });
            } catch (err) {
                console.error("Error updating grid/counts:", err);
                showMessage("Error saving placement. Reverting.");
                 // Revert optimistic update
                 myPlayer.grid[coord] = oldGridValue;
                 myPlayer.shipsPlaced = oldShips;
                 myPlayer.minesPlaced = oldMines;
                 renderGameUI(localGameData);
            }
        }


        /**
         * Handles the "Ready" button click. Uses dot notation.
         */
        async function handleReadyClick() {
            readyButton.disabled = true; // Disable immediately
            
            const myPlayer = localGameData.players[userId];
             if (!myPlayer || myPlayer.shipsPlaced !== SHIP_COUNT || myPlayer.minesPlaced !== MINE_COUNT) { 
                 showMessage(`You must place all ${SHIP_COUNT} ships and ${MINE_COUNT} mines.`);
                 readyButton.disabled = false; // Re-enable if invalid
                 return;
            }

             // Optimistic UI update
            const wasReady = myPlayer.ready;
            myPlayer.ready = true;
            renderGameUI(localGameData); // Show waiting state immediately


            const roomRef = doc(db, getRoomPath());
            try {
                 // Update just my ready status first
                 await updateDoc(roomRef, {
                     [`players.${userId}.ready`]: true
                 });

                 // Re-fetch the latest data to check if everyone is ready *now*
                 // This avoids a race condition where two players click ready simultaneously
                 const updatedDocSnap = await getDoc(roomRef);
                 if (updatedDocSnap.exists()) {
                     const updatedRoomData = updatedDocSnap.data();
                     const allPlayers = Object.values(updatedRoomData.players || {});
                     const allReady = allPlayers.length > 0 && allPlayers.every(p => p.ready);

                     if (allReady && updatedRoomData.gameState === 'setup') {
                        // If everyone is now ready, transition to playing state
                        console.log("All players ready, starting game!");
                        await updateDoc(roomRef, {
                            gameState: "playing",
                            currentPlayerIndex: 0, // Reset turn index
                            gameLog: arrayUnion({ type: 'game', message: "All players are ready! The battle begins!" })
                        });
                     }
                 }

            } catch (err) {
                console.error("Error setting ready status or starting game:", err);
                showMessage("Error setting ready status. Please try again.");
                // Revert optimistic update on error
                myPlayer.ready = wasReady;
                renderGameUI(localGameData);
                readyButton.disabled = false; // Re-enable button on error
            }
            // Button remains disabled on success
        }


        /**
         * Handles an attack on an opponent.
         * @param {string} targetPlayerId - The ID of the player being attacked.
         * @param {number} cellIndex - The cell index being attacked (0-35). NOT USED directly for update.
         * @param {string} coord - The coordinate string (e.g., "A1"). USED for update.
         */
        async function handleAttackClick(targetPlayerId, cellIndex, coord) {
            cancelMove();
            opponentGridsContainer.style.pointerEvents = 'none'; // Disable opponent grids during processing

            // Refetch latest data to minimize race conditions during attack
            const roomRef = doc(db, getRoomPath());
            let currentRoomData;
            try {
                const roomSnap = await getDoc(roomRef);
                if (!roomSnap.exists()) throw new Error("Room data missing");
                currentRoomData = roomSnap.data();
            } catch (err) {
                console.error("Failed to fetch latest room data before attack:", err);
                showMessage("Network error. Please try attacking again.");
                opponentGridsContainer.style.pointerEvents = 'auto'; // Re-enable on error
                return;
            }

             // Verify turn and target validity with the fresh data
             if (!currentRoomData.playerIds || currentRoomData.playerIds.length === 0) {
                 console.error("Player order missing in fetched data.");
                 showMessage("Game error. Please refresh.");
                 opponentGridsContainer.style.pointerEvents = 'auto';
                 return;
             }
            const currentPlayerId = currentRoomData.playerIds[currentRoomData.currentPlayerIndex];
            if (currentPlayerId !== userId) {
                 console.warn("Not your turn based on fresh data.");
                 // Don't show message, UI should update shortly
                 opponentGridsContainer.style.pointerEvents = 'auto';
                 return;
             }
            const attacker = currentRoomData.players[userId]; // Use fresh data
            const targetPlayer = currentRoomData.players[targetPlayerId];

             if (!targetPlayer || targetPlayer.isOut) {
                console.warn("Target player not found or is out based on fresh data.");
                showMessage("Invalid target."); // Should be rare
                opponentGridsContainer.style.pointerEvents = 'auto';
                return;
            }

            if (typeof targetPlayer.grid[coord] === 'object') {
                showMessage("That position has already been attacked!");
                opponentGridsContainer.style.pointerEvents = 'auto'; 
                return;
            }
            
            // --- Determine outcome ---
            const targetCell = targetPlayer.grid[coord]; 
            const wasHit = targetCell === 1;
            const wasMine = targetCell === 2; 
            const coordForLog = coord; 
            
            let logMsg = { type: 'game', message: "" };
            let newLogMessages = [];
            let updatePayload = {}; // Build the update object atomically
            
            const attackerColor = attacker.color || DEFAULT_COLOR; 
            let newShipsLeft = targetPlayer.shipsLeft;
            let newIsOut = targetPlayer.isOut;
            let attackerWillSkip = attacker.isSkippingTurn; // Start with current skip state

             if (wasHit) {
                logMsg.message = `${attacker.name} attacked ${targetPlayer.name} at ${coordForLog}... HIT! üö¢`;
                updatePayload[`players.${targetPlayerId}.grid.${coord}`] = { type: 'hit', attackerId: attacker.userId, attackerColor: attackerColor };
                newShipsLeft--;
                 updatePayload[`players.${targetPlayerId}.shipsLeft`] = newShipsLeft;
                if (newShipsLeft === 0) {
                    newIsOut = true;
                    updatePayload[`players.${targetPlayerId}.isOut`] = true;
                    newLogMessages.push({ type: 'game', message: `${targetPlayer.name} has been eliminated!` });
                }
            } else if (wasMine) { 
                logMsg.message = `${attacker.name} attacked ${targetPlayer.name} at ${coordForLog}... IT'S A MINE! üí•`;
                updatePayload[`players.${targetPlayerId}.grid.${coord}`] = { type: 'mine-hit', attackerId: attacker.userId, attackerColor: attackerColor };
                 updatePayload[`players.${userId}.isSkippingTurn`] = true; // Attacker skips next turn
                 attackerWillSkip = true; // Update local flag for later check
                newLogMessages.push({ type: 'game', message: `${attacker.name} hit a mine and will skip their next turn!` });
            } else {
                logMsg.message = `${attacker.name} attacked ${targetPlayer.name} at ${coordForLog}... MISS! X`;
                updatePayload[`players.${targetPlayerId}.grid.${coord}`] = { type: 'miss', attackerId: attacker.userId, attackerColor: attackerColor };
            }
            
            newLogMessages.unshift(logMsg); 
            updatePayload.gameLog = arrayUnion(...newLogMessages);
            updatePayload.lastTargetCoord = coord; // NEW: Update last target
            updatePayload.lastTargetPlayerId = targetPlayerId; // NEW: Update last target

             // --- Check for game over (based on potential updates) ---
             let newGameState = currentRoomData.gameState;
             let newWinner = currentRoomData.winner;
             let nextPlayerIndex = currentRoomData.currentPlayerIndex;

             // Temporarily apply changes to check game over state
             const tempPlayers = JSON.parse(JSON.stringify(currentRoomData.players)); // Deep copy
             if(updatePayload[`players.${targetPlayerId}.isOut`]) {
                 tempPlayers[targetPlayerId].isOut = true;
             }
             const playersStillIn = Object.values(tempPlayers).filter(p => !p.isOut);

            if (playersStillIn.length === 1) {
                newGameState = "over";
                newWinner = playersStillIn[0].userId; // Note: userId is key, but player object needed for name
                updatePayload.gameState = newGameState;
                updatePayload.winner = newWinner;
                 // Add game over log message directly here if needed, or rely on the elimination message
                // updatePayload.gameLog = arrayUnion(...newLogMessages, { type: 'game', message: `GAME OVER! ${playersStillIn[0].name} is the winner!` });

            } else if (playersStillIn.length === 0) { // Should be rare, implies simultaneous elimination?
                newGameState = "over";
                newWinner = null; // Draw
                updatePayload.gameState = newGameState;
                updatePayload.winner = newWinner;
                // updatePayload.gameLog = arrayUnion(...newLogMessages, { type: 'game', message: "GAME OVER! It's a draw!" });
            }
            
            // --- Determine next turn ---
            // Turn only advances on a MISS or a MINE HIT (and game not over)
            if (newGameState === "playing" && !wasHit) {
                 const playerIds = currentRoomData.playerIds; // Use the ordered list
                 if (playerIds && playerIds.length > 0) {
                    let attempts = 0;
                    do {
                         nextPlayerIndex = (nextPlayerIndex + 1) % playerIds.length;
                         attempts++;
                    } while (currentRoomData.players[playerIds[nextPlayerIndex]]?.isOut && attempts < playerIds.length * 2); // Find next active player

                    if(attempts >= playerIds.length * 2) {
                        console.error("Could not find next active player, potential infinite loop averted.");
                        // Handle error state? Maybe declare a draw?
                    } else {
                        updatePayload.currentPlayerIndex = nextPlayerIndex;
                    }

                 } else {
                     console.error("playerIds missing or empty, cannot advance turn.");
                 }
            }
            
            // --- Execute the combined update ---
            try {
                await updateDoc(roomRef, updatePayload);
                // No need to re-enable opponent grids here, snapshot listener will trigger re-render
            } catch (err) {
                console.error("Error during attack update:", err);
                showMessage("Error processing attack. Please try again.");
                opponentGridsContainer.style.pointerEvents = 'auto'; // Re-enable on error
            } 
        }

        /**
         * Handles the automatic turn skip after hitting a mine.
         * Uses dot notation.
         */
        async function handleSkipTurn() {
             if (!localGameData || !localGameData.playerIds || localGameData.playerIds.length === 0) {
                 console.warn("Cannot skip turn: localGameData or playerIds missing.");
                 return;
             }
            
            // Find next player index
            let nextPlayerIndex = localGameData.currentPlayerIndex;
            const playerIds = localGameData.playerIds;
            let attempts = 0;
            do {
                nextPlayerIndex = (nextPlayerIndex + 1) % playerIds.length;
                attempts++;
            } while (localGameData.players[playerIds[nextPlayerIndex]]?.isOut && attempts < playerIds.length * 2); // Check if next player is out

             if (attempts >= playerIds.length * 2) {
                 console.error("Could not find next active player for skip turn.");
                 // Maybe game should have ended? Or handle draw?
                 return;
             }
            
            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, {
                    [`players.${userId}.isSkippingTurn`]: false, // Reset my skip status
                    currentPlayerIndex: nextPlayerIndex,
                    gameLog: arrayUnion({ type: 'game', message: `${myPlayerName} skipped their turn due to hitting a mine.` })
                });
            } catch (err) {
                console.error("Error skipping turn:", err);
                 // If the update fails, the UI might remain stuck. 
                 // A refresh might be needed, or more complex error handling.
            }
        }


        /**
         * Handles sending a chat message.
         */
        async function handleSendChat() {
            const message = chatInput.value.trim();
            if (!message) return;
             if (!localGameData || isSpectator) { // Check spectator status
                 return; // Spectators cannot chat
             }
            
            // Allow eliminated players to chat
            const myPlayer = localGameData.players[userId];
            // if (!myPlayer) return; // Allow chat even if briefly missing due to race condition? Maybe not.

            chatInput.disabled = true;
            chatSendButton.disabled = true;

            const myColor = myPlayer?.color || DEFAULT_COLOR;
            const myName = myPlayerName || "Player"; // Fallback name

            const chatObject = { 
                type: 'chat', 
                name: myName, 
                color: myColor, 
                message: message 
            };

            const roomRef = doc(db, getRoomPath());
            try {
                await updateDoc(roomRef, { 
                    gameLog: arrayUnion(chatObject) 
                });
                chatInput.value = ''; // Clear input on success
            } catch (err) {
                console.error("Error sending chat:", err);
                showMessage("Error sending message. Please try again.");
            } finally {
                // Re-enable even if player data briefly disappeared
                chatInput.disabled = false;
                chatSendButton.disabled = false;
                chatInput.focus();
            }
        }
        
        // --- REVISED: Ship Moving Functions ---

        /**
         * Calculates valid adjacent move destinations based on grid index.
         * @param {number} fromIndex - The grid index (0-35) to move from.
         * @param {object} grid - The player's grid map (coord: state).
         */
        function calculateValidMoves(fromIndex, grid) {
            validMoveIndices = [];
            const { row, col } = toRowCol(fromIndex);
            
            const potentialMoves = [
                { r: row - 1, c: col }, // Up
                { r: row + 1, c: col }, // Down
                { r: row, c: col - 1 }, // Left
                { r: row, c: col + 1 }  // Right
            ];

            for (const move of potentialMoves) {
                if (move.r >= 0 && move.r < GRID_SIZE && move.c >= 0 && move.c < GRID_SIZE) {
                    const toIndex = toIndex(move.r, move.c);
                    const toCoord = toGridCoord(toIndex); 
                    if (toCoord && grid[toCoord] === 0) { 
                        validMoveIndices.push(toIndex); // Store index for UI interaction
                    }
                }
            }
        }

        /**
         * Cancels the "Move Ship" state.
         */
        function cancelMove() {
            if (shipToMoveIndex !== null || validMoveIndices.length > 0) {
                shipToMoveIndex = null;
                validMoveIndices = [];
                // No need to re-render immediately, next update or action will handle it
                console.log("Move cancelled.");
            }
        }

        /**
         * Executes a silent ship move. Does NOT cost a turn. Uses dot notation.
         * @param {number} fromIndex - The grid index to move from.
         * @param {number} toIndex - The grid index to move to.
         */
        async function executeSilentMove(fromIndex, toIndex) {
            gameStatus.textContent = "Moving ship...";
            myGridContainer.style.pointerEvents = 'none'; // Disable grid during move

            const myPlayer = localGameData.players[userId];
            if (!myPlayer) return; // Safety check

            const fromCoord = toGridCoord(fromIndex);
            const toCoord = toGridCoord(toIndex);

            if (!fromCoord || !toCoord || myPlayer.grid[fromCoord] !== 1 || myPlayer.grid[toCoord] !== 0) {
                console.error("Invalid move parameters for executeSilentMove", fromCoord, toCoord, myPlayer.grid);
                showMessage("Invalid move. Cancelling.");
                 cancelMove();
                 renderGameUI(localGameData); // Re-render to clear highlights
                 myGridContainer.style.pointerEvents = 'auto';
                 return;
            }

            // Optimistic UI Update
             const oldGrid = { ...myPlayer.grid }; // Store old grid for revert
             myPlayer.grid[fromCoord] = 0;
             myPlayer.grid[toCoord] = 1;
             hasMovedShipThisTurn = true; // Set flag *before* cancelling move state
             const wasMovingIndex = shipToMoveIndex; // Store index before cancelling
             cancelMove();
             renderGameUI(localGameData); // Re-render immediately without highlights
             myGridContainer.style.pointerEvents = 'auto'; // Re-enable grid interaction


            const roomRef = doc(db, getRoomPath());
            try {
                // Update Firestore using dot notation for specific grid cells
                await updateDoc(roomRef, {
                    [`players.${userId}.grid.${fromCoord}`]: 0,
                    [`players.${userId}.grid.${toCoord}`]: 1
                });
                 console.log(`Moved ship from ${fromCoord} to ${toCoord}`);
            } catch (err) {
                console.error("Error moving ship:", err);
                showMessage("Error moving ship. Reverting move.");
                // Revert optimistic update
                 myPlayer.grid = oldGrid;
                 hasMovedShipThisTurn = false;
                 shipToMoveIndex = wasMovingIndex; // Restore move state if needed
                 renderGameUI(localGameData); // Re-render to show reverted state
            }
        }


        // --- PeerJS Cleanup Functions ---

        /**
         * Cleans up a single peer connection.
         * @param {string} peerId - The PeerJS ID of the player to disconnect from.
         */
        function cleanupPeerConnection(peerId) {
             if (!peerId) return; // Safety check
            if (voiceConnections[peerId]) {
                console.log(`Closing connection to ${peerId}`);
                voiceConnections[peerId].close();
                delete voiceConnections[peerId];
            }
            if (audioElements[peerId]) {
                audioElements[peerId].srcObject = null; // Detach stream first
                audioElements[peerId].remove();
                delete audioElements[peerId];
            }
            console.log(`Cleaned up connection for ${peerId}`);
        }

        /**
         * Cleans up all voice chat state (on leave/logout).
         */
        function cleanupAllVoice() {
            console.log("Cleaning up all voice connections...");
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                console.log("Stopped local stream.");
            }
            
            // Close existing connections before destroying peer
            Object.keys(voiceConnections).forEach(cleanupPeerConnection);
             voiceConnections = {};
             audioElements = {};
             audioStreamsContainer.innerHTML = ''; // Clear any remaining audio elements

            if (peer) {
                 if (!peer.destroyed) {
                    peer.destroy();
                    console.log("Destroyed PeerJS instance.");
                 }
                peer = null;
            }

            
            muteSelfButton.classList.add('hidden');
            voiceChatButton.classList.add('hidden'); // Keep hidden until game screen shown
            voiceChatButton.disabled = false;
            voiceChatButton.textContent = "Join Voice üéôÔ∏è";
            isMuted = false;
        }


        // --- Screen Management ---
        
        function showLoginScreen() {
            loadingScreen.classList.add('hidden');
            gameScreen.classList.add('hidden');
            loginScreen.classList.remove('hidden');
            
            if (unsubscribeRoom) {
                console.log("Unsubscribing from room listener.");
                unsubscribeRoom();
                unsubscribeRoom = null;
            }
            localGameData = null;
            currentRoomCode = null;
            isSpectator = false; 
            isHost = false; // Reset host status
            
            cleanupAllVoice(); 
            
            cancelMove(); 
            hasMovedShipThisTurn = false; 
            
            joinButton.disabled = false;
            joinButton.textContent = "Join Game";
            createRoomButton.disabled = false;
            createRoomButton.textContent = "Create New Game";
        }
        
        function showGameScreen() {
            loadingScreen.classList.add('hidden');
            loginScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            
            // Only show voice button if NOT a spectator
            voiceChatButton.classList.toggle('hidden', isSpectator);
            // Mute button visibility depends on voice state, handled later
            muteSelfButton.classList.add('hidden'); 
        }

        // --- Firebase Initialization ---

        async function signIn() {
            try {
                // Check for the global token provided by the Canvas environment
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                     console.log("Signing in with custom token...");
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                     console.log("Signing in anonymously...");
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Sign-In Error:", error);
                loadingScreen.innerHTML = `<h1>Auth Error</h1><p>Could not sign in: ${error.message}. Check console and Firebase settings.</p>`;
            }
        }

        // --- NEW: Host Migration Logic ---
        async function checkAndHandleHostMigration(roomData) {
            if (!roomData || !roomData.creatorId || !roomData.players) return; // Need essential data

             const currentHostId = roomData.currentHostId || roomData.creatorId;
             const hostExists = roomData.players[currentHostId]; // Check if current host is still in the players map

             // Only migrate if host is missing AND game is in waiting/setup
             if (!hostExists && (roomData.gameState === 'waiting' || roomData.gameState === 'setup')) {
                 console.log(`Host (${currentHostId}) seems to have left.`);
                 const playerIds = Object.keys(roomData.players);
                 if (playerIds.length > 0) {
                     const newHostId = playerIds[0]; // Simple: first player in map becomes new host
                     console.log(`Attempting to assign new host: ${newHostId}`);

                     // Only the *new host* should attempt the update to avoid race conditions
                     if (newHostId === userId) {
                        const roomRef = doc(db, getRoomPath());
                         try {
                             await updateDoc(roomRef, {
                                 currentHostId: newHostId,
                                 gameLog: arrayUnion({ type: 'game', message: `${roomData.players[newHostId]?.name || 'New host'} has become the host.` })
                             });
                             console.log("Successfully claimed host status.");
                             isHost = true; // Update local state immediately
                         } catch (err) {
                             console.error("Error claiming host status:", err);
                             // Another player might have claimed it first, which is okay.
                         }
                     } else {
                         console.log("Waiting for new host to claim status.");
                     }
                 } else {
                     console.log("No players left to assign host.");
                     // Potentially delete the room or mark as abandoned?
                 }
             } else if (hostExists) {
                 // Update local host status if it changed (e.g., on join/rejoin)
                 isHost = userId === currentHostId;
             }
         }


        function listenToRoom() {
            if (unsubscribeRoom) {
                console.warn("Already listening to a room. Unsubscribing first.");
                unsubscribeRoom();
            }
            
            console.log(`Listening to room: ${currentRoomCode}`);
            const roomRef = doc(db, getRoomPath());
            unsubscribeRoom = onSnapshot(roomRef, (docSnap) => {
                if (docSnap.exists()) {
                    const oldLocalGameData = localGameData; // Keep for comparison
                    const newRoomData = docSnap.data();
                    localGameData = newRoomData; // Update global state
                    
                     // --- Host Migration Check ---
                     checkAndHandleHostMigration(newRoomData);

                    // --- PeerJS Connection Management ---
                    if (peer && localStream && newRoomData.players) { 
                        const playerMap = newRoomData.players;
                        const otherPlayersInVoice = Object.entries(playerMap)
                            .filter(([id, p]) => id !== userId && p.peerId)
                            .map(([id, p]) => p); // Get player objects
                         const otherPlayerPeerIds = otherPlayersInVoice.map(p => p.peerId);
                        
                        // Connect to new players
                        otherPlayersInVoice.forEach(player => {
                            if (player.peerId && !voiceConnections[player.peerId]) { // Check peerId exists
                                callPlayer(player.peerId);
                            }
                        });
                        
                        // Disconnect from leavers/those without peerId now
                         Object.keys(voiceConnections).forEach(peerId => {
                            if (!otherPlayerPeerIds.includes(peerId)) {
                                cleanupPeerConnection(peerId);
                            }
                        });
                    }
                    // --- End PeerJS ---
                    

                    // Reset move state if the turn has changed away from me
                     if (!isSpectator && newRoomData.players && newRoomData.players[userId] && oldLocalGameData && oldLocalGameData.playerIds && newRoomData.playerIds) {
                        const oldPlayerId = oldLocalGameData.playerIds[oldLocalGameData.currentPlayerIndex];
                        const newPlayerId = newRoomData.playerIds[newRoomData.currentPlayerIndex];
                         if (oldPlayerId === userId && newPlayerId !== userId) {
                             // Turn just changed away from me
                            hasMovedShipThisTurn = false;
                            cancelMove();
                            console.log("Turn changed away, reset move state.");
                        }
                    }

                    // Reset pointer events before render
                    opponentGridsContainer.style.pointerEvents = 'auto';
                    myGridContainer.style.pointerEvents = 'auto';
                    
                    renderGameUI(newRoomData); // Render with the latest data

                    // Disable grids based on state *after* rendering
                     if (!isSpectator && newRoomData.gameState === 'playing' && newRoomData.players && newRoomData.players[userId]) {
                        const myPlayer = newRoomData.players[userId];
                        if (myPlayer.isOut) {
                            opponentGridsContainer.style.pointerEvents = 'none';
                            myGridContainer.style.pointerEvents = 'none';
                        } else {
                            // Determine current player using the potentially updated index and playerIds
                            const playerIds = newRoomData.playerIds;
                            if (playerIds && playerIds.length > newRoomData.currentPlayerIndex) {
                                const currentPlayerId = playerIds[newRoomData.currentPlayerIndex];
                                const isMyTurn = currentPlayerId === userId;
                                if (isMyTurn) {
                                    if(myPlayer.isSkippingTurn || shipToMoveIndex !== null) {
                                        opponentGridsContainer.style.pointerEvents = 'none';
                                    }
                                    if(myPlayer.isSkippingTurn) { // Disable my grid too if skipping
                                         myGridContainer.style.pointerEvents = 'none';
                                    }
                                } else {
                                     // Not my turn, disable interactions
                                     opponentGridsContainer.style.pointerEvents = 'none';
                                     myGridContainer.style.pointerEvents = 'none'; // Can't move opponent's ships
                                }
                            } else {
                                console.warn("PlayerIds or currentPlayerIndex invalid, disabling grids as safety.");
                                opponentGridsContainer.style.pointerEvents = 'none';
                                myGridContainer.style.pointerEvents = 'none';
                            }
                        }
                    } else if (newRoomData.gameState !== 'setup' && newRoomData.gameState !== 'playing') {
                        // If not setup or playing (e.g., waiting, over), disable grids generally
                        opponentGridsContainer.style.pointerEvents = 'none';
                        myGridContainer.style.pointerEvents = 'none';
                    }


                    // Show game over modal with a delay
                    if (oldLocalGameData?.gameState !== 'over' && newRoomData.gameState === 'over') {
                        setTimeout(() => {
                            // Check again in case state changed back quickly
                            if (localGameData && localGameData.gameState === 'over') {
                                 gameOverModal.classList.remove('hidden');
                            }
                        }, 1000);
                    }
                } else {
                    console.log("Room document no longer exists.");
                    showMessage("The game room no longer exists.");
                    showLoginScreen();
                }
            }, (error) => {
                console.error("Firestore Snapshot Error:", error);
                showMessage("Lost connection to game room. Please check console.");
                showLoginScreen();
            });
        }
        
        window.onload = () => {
            if (typeof Peer === 'undefined') {
                loadingScreen.innerHTML = "<h1>Error</h1><p>Could not load voice chat library (PeerJS). Please check your internet connection and refresh.</p>";
                return;
            }

            if (!firebaseConfig.apiKey || !firebaseConfig.projectId) {
                 loadingScreen.innerHTML = "<h1>Error</h1><p>Firebase is not configured. Please check the `firebaseConfig` object in the script.</p>";
                return;
            }
            
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug'); 

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Authenticated with userId:", userId);
                        showLoginScreen(); 
                    } else {
                        console.log("User is not authenticated. Attempting sign-in...");
                        signIn();
                    }
                });

                // --- Bind Event Listeners ---
                createRoomButton.addEventListener('click', handleCreateRoom);
                joinButton.addEventListener('click', handleJoinRoom);
                startGameButton.addEventListener('click', handleStartGame);
                voiceChatButton.addEventListener('click', handleJoinVoiceChat);
                muteSelfButton.addEventListener('click', handleMuteSelf);
                
                myGridContainer.addEventListener('click', handleGridClick);
                opponentGridsContainer.addEventListener('click', handleGridClick);
                
                readyButton.addEventListener('click', handleReadyClick);
                
                roomColorPicker.addEventListener('click', handleColorSelectInRoom); 
                
                chatSendButton.addEventListener('click', handleSendChat);
                chatInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') {
                        handleSendChat();
                    }
                });
                
                messageOkButton.addEventListener('click', () => {
                    messageModal.classList.add('hidden');
                });
                
                playAgainButton.addEventListener('click', () => {
                    // Clean up voice connections before reload
                    cleanupAllVoice();
                    window.location.reload();
                });

                roomInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') joinButton.click();
                });

                 // Optional: Add beforeunload listener for better cleanup
                 window.addEventListener('beforeunload', () => {
                    console.log("beforeunload triggered, cleaning up voice.");
                     cleanupAllVoice();
                     // Note: You cannot reliably perform async operations like Firestore updates here.
                 });

            } catch (err) {
                console.error("Firebase Init Error:", err);
                loadingScreen.innerHTML = "<h1>Error</h1><p>Could not initialize the application.</p>";
            }
        };

    </script>
</body>
</html>

